---
title: 设计模式
date: 2024-05-01
updated: 2024-06-21
comments: true
cover: https://www.runoob.com/wp-content/uploads/2014/08/mmexport1707099938077.png
---
# 设计模式

![设计模式](https://www.runoob.com/wp-content/uploads/2014/08/mmexport1707099938077.png)

## 第一章 六大软件设计原则

### 1. 开闭原则 OCP

​	**开闭原则（Open-Closed Principle）：**对现有程序的扩展开发，对修改关闭。
==老子的代码写好了，就尽量不要改老子的代码了，要改自己写一个去。虽然你可以改老子的代码==

>
>
>“当需要修改或增强系统的功能时，应优先考虑通过增加新代码（比如添加新的类、方法或模块）的方式来实现需求变更，而不是直接修改原有的已验证无误的基础代码部分。”

### 2.里氏替换原则 LSP

​	**里氏替换原则（Liskov Substitution Principle）：**任何父类出现的地方，子类一定**可以**出现。子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。
==老爹能干的，他的儿子也能干，虽然干的活一模一样，但是儿子还可以干别的。==

>​	里氏替换原则强调在软件设计中，子类应当能够在其父类出现的地方正确地工作，且不会引起意外的行为。
>
>​	“老爹能干的，他的儿子也能干”，这表示子类至少要完全实现父类的功能，即子类对于父类的接口而言是兼容的，可以无差别地替换父类实例；而“虽然干的活一模一样，但是儿子还可以干别的”则体现了子类不仅可以完成父类定义的任务，而且还能根据需要扩展新的功能或行为，但这些扩展不应该破坏原有的继承体系和契约约定。
>​	总结来说，里氏替换原则要求在设计时确保任何基类的引用都能够透明地使用其子类的对象，同时子类可以在不违反契约的情况下扩展功能，保持系统的开放性和可维护性。

### 3. 依赖倒置原则 DIP

​        **依赖倒置原则（Dependence Inversion Principle）：**高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。针对接口编程，不要针对实现编程。

==我想揍你，我该怎么揍你啊？我可以用我的拳头揍你，但是我也可以使用棍子揍你。==

SSM 开发中`控制层`通过`服务层接口`来调用服务层`实现类的方法`。

>"我想揍你"可以看作是一个高层模块的需求，而"我可以用我的拳头揍你"则是具体的一种实现方式。
>
>​	抽象需求：揍你
>​	这代表了系统中的一种行为或操作，即执行揍人的动作。
>
>​	具体实现1：用拳头揍你
>​	这是满足揍人需求的一个具体方法，可以视为一个低层模块的具体实现。
>
>​	具体实现2：用棍子揍你
>​	同样也是满足揍人需求的不同方式，另一个低层模块的具体实现。
>
>
>
>​	高层模板“我想揍你”依赖于“揍你”的这个接口，而低层模块，即揍你的“实现”方式（通过拳头 or 棍子）也依赖于“揍你”这个接口。
>
>​	高层模块调用了接口中的抽象方法，实际上调用了接口实现类的方法。
>
> ​	高层模块（例如：我控制我揍你）不应该直接依赖于低层的具体实现（例如：拳头攻击或棍子攻击），而是应该依赖于抽象接口（例如：攻击策略接口）。



### 4. 接口隔离原则 ISP

​	**接口隔离原则（Interface Segregation Principle）：**客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。

（妈妈，你怎么准备这么多东西啊，我只是去上学，不是搬家啊QAQ，带不了了。这些东西我放家里了，那些我东西才要带到学校。）

>“妈妈准备的东西”：代表了一个大而全的接口，包含了多种功能或职责。
>
>“我只是去上学，不是搬家”：意味着作为客户端（即“我”）只需要其中一部分功能，而非全部。
>
>“这些东西我放家里，那些我才带到学校”：表示应该把不必要的接口部分“留在家里”，只携带符合需求的、精简的接口（方法）到“学校”（即实际使用的代码模块中）。
>
>所以，通过这个比喻，我们可以理解为接口隔离原则提倡我们将一个大的接口拆分成多个更小、更具有针对性的接口，使得每个接口都只包含一组相关的操作，避免了不使用的方法对客户端产生的影响和耦合。

接口隔离原则（ISP）的核心思想，即避免一个接口包含过多不相关的职责，导致客户端不得不依赖它不需要的方法。通过把不必要的部分“留在家里”，只携带符合需求的、更小的接口到“学校”（类或模块中），体现了接口隔离的原则。

​	**在实际编程实践中，接口隔离原则更加关注的是如何设计和拆分接口，使得每个接口都具有良好的内聚性，从而降低耦合度，提高代码的可维护性和复用性。**



### 5.合成复用原则 CRP

**合成复用原则（Composite Reuse Principal）：**组合/聚合复用原则，尽量使用对象组合，而不是继承来达到复用的目的。

==（这个工具类大家直接过来拿去用吧，不用自己重复写了）==

通过工具类的对象来调用工具类的方法来解决问题，而不是继承工具类来使用工具类的方法。



### 6.迪米特法则 LoD

​	**迪米特法则（Law of Demeter）：**最少知识原则

典型的定义：

- 不要和“陌生人”说话；
- 只与你的直接朋友通信；
- 每一个软件单位对其他的单位都只有最小的知识，而且局限于那些与本单位密切相关的软件单位。

==（我是社恐，朋友不多但关系较好，有问题直接找他们帮忙，当然他们有能力独立解决问题，而我也不敢找别人。）==





### **怎么？还没理解？？**

- 我又想到好法子了，但是我不改上面的东西了，我要再下面写新的了（开闭原则，对修改关闭，对扩展开放）；
- 我的好法子其实也没有什么变化，好像是骗你的，我就是复制一下上面的东西展示给你吧，此处省略两千字。。。虽然我确实新加了一些新的东西。（里氏替换原则，假设这句话是子类，上面的是父类，那么子类没有重写父类的方法，而且是原封不动的使用父类的方法）；
- 其实我确实没有啥好法子了，我还是给个连接让你看看我之前怎么写的吧。（依赖倒置原则，我通过一个连接（抽象）连接到具体的知识内容（实现类））
- 我感觉没必要写更多了，写多了好像跟这篇文章没有关系了（接口隔离法则，客户端不应该直接依赖哪些它不需要的接口）



如果有错误的地方，欢迎大家指出，我会修改，谢谢大家花时间阅读。

# 结构性模式

> 结构式模式描述了两种不同的东西：类与类的实例（即对象）
>
> - 类结构型模型：关心类的组合（**继承和实现关系**）
> - 对象结构式模型：关系类与对象的组合（通过**关联关系**使得在一个类中定义另一个类的实例对象，通过该对象调用其方法）
>
> 根据“合成复用原则”，在系统中应当**尽量使用关联关系来替代继承关系**，因此大部分结构型模式都是**对象结构型模式**



## 1. 适配器模式

> 目标通过适配器用了适配者的方法。

### 定义

定义：将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器（Wrapper）。

适配器：通过一个设备，使原本不兼容的事物可以一起工作，这个设备叫做适配器。如充电头转换器。



适配器模式描述如何将类或者对象结合在一起形成更大的结构。

> - 适配器使适配者类具有更多的能力。



适配器模式的结构

适配器模式通常包含以下角色：

1. Target（目标抽象类）
   - 目标抽象类可以是一个抽象类，也可以是一个接口，也可以是一个具体的类
   - 定义了客户端要用的特定领域的接口
2. Adaptee（适配者类）
   - 适配者即被适配的角色，一般是一个具体的类
   - 适配者类定义了一个接口，这个接口需要适配
3. Adapter（适配器类）
   - 适配器类可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配
     - 在类适配器中，适配器类通过实现 Target 接口，继承Adaptee 类使二者产生联系；
     - 在对象适配器中，适配器通过实现 Target 接口，关联一个 Adaptee 对象使二者产生联系。
4. Client（客户类）
   - 针对目标抽象类进行编程，调用目标抽象类中定义的业务方法。



### 代码分析

Target 目标抽象类（实际上是一个接口，里面定义了一个方法）

```java
public interface Target{
    void request();
}
```



Adaptee 适配者类

```java
public class Adaptee{
    public void specificRequest(){
        System.out.println("调用适配方法");
    }
}
```



Adapt 适配器类（对象适配器，实现了目标抽象类接口，关联了一个 Adaptee 对象）

```java
public class Adapter implement Target{
    private Adaptee adaptee;
    public Adapter(Adaptee adaptee){
        this.adaptee = adpatee;
    }
    public void request(){
        adaptee.specificRequest();
    }
}
```

客户端

```java
public class Client{
    public static void main(String [] args){
        Target target = new Adapter();
        adapter.request();
    } 
}
```



### 适配器模式的优缺点

优点 ：

无论是类适配器还是对象适配器，都具有以下优点：

1. 将目标类和适配者类进行解耦（通过引入一个适配器类来重用现有的适配者类，无需修改原有的代码）
2. 增加了类的透明性和复用性（将具体的实现封装在适配者类中，对于客户端来说是透明的，而且提高适配者的复用性）
3. 灵活性和扩展性非常好（通过使用配置文件，可以更好地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，符合开闭原则）



对象适配器的优点还有：

- 对象适配器可以把多个不同的适配者适配到同一个目标（同一个适配器可以把适配者类和它的子类都适配到目标接口）。



缺点：

类适配器的缺点：

- 一次最多只能适配一个适配者类，而且目标抽象类只能是接口，不能为类，具有一定的局限性；
- 不能将一个适配者类和它的子类都适配到目标接口；

对象适配器的缺点：

* 与类适配器相比，想要置换适配者类的一个或多个方法，就只好先做一个适配者类的子类，将适配者类的方法置换掉，再把适配者类的子类当作真正的适配者进行适配，实现过程较复杂。

### 适配器模式适用场景

- 系统需要使用现有的类，而这些类的接口不符合系统的需要
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关系的一些类，包括一些可能在未来引进的类一起工作。



## 2. 桥接模式（待补充）

> 柄体模式、接口模式。

抽象关联替代多重继承，类之间的静态继承转换为动态的对象组合关系。

### 定义

桥接模式：将抽象部分和它的实现部分分离，使它们可以独立地变化。

桥接模式具有以下的角色：

Abstract（抽象类）







## 3. 组合模式

组合模式类似于树形结构，终点都是叶子对象（单个对象），中间的都是容器对象（组合对象）

组合模式关注那些存在叶子构件和容器构件的结构以及它们的组织形式；

- 叶子构件不能包含成员对象，容器构件能包含成员对象。
- 成员对象可以是叶子构件，也可以是容器构件。
- 这些对象可以构成一个树形结构，组合模式使用面向对象的方式处理树形结构，
- 叶子构件和容器构件具有一个公共的抽象构件类，客户端可以针对该抽象类进行处理，不用关心是哪一种类型的对象。

**动机：**如何将容器对象和叶子对象进行递归组合，使用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象。

定义

**组合模式：**组合多个对象形成树形结构，以表示“部分--整体”的结构层次。组合模式对单个对象和组合对象的使用具有一致性。

组合模式具有以下角色：

1. Component（抽象构件）：定义了访问及管理它的子构件的方法
   - 可以是接口，也可以是抽象类
   - 为叶子构件和容器构件对象声明接口，在该对象中可以包含所有子类共有行为的声明和实现。
   - 增加子构件、删除子构件、获取子构件等等方法。
2. Leaf（叶子构件）：叶子节点对象
   - 叶子节点没有子节点，实现了抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式来处理。
3. Composite（容器构件）：容器节点对象
   - 容器构件包含子节点（可以是叶子节点，也可以是容器节点【通过集合的形式存储子节点】）
   - 实现了在抽象构件中定义的行为，包含访问和管理子构件的方法；
   - 其业务方法可以递归调用其子节点的业务方法。
4. Client（客户端）：通过抽象构件接口访问和控制组合构件的对象。





### 代码

抽象构件类：含有访问及管理其子构件的方法。

```java
public interface Component{
    void add(Component component);
    void remove(Component component);
    Component get(int i);
    void operation();
}
```

叶子构件类：对于访问子节点的方法进行异常处理或错误提示，实现其业务方法

```java
public class Leaf implements Component{
    void add(Component component){
        // 异常处理
    }
    void remove(Component component){
        // 异常处理
    }
    Component get(int i){
        // 异常处理
    }
    void operation(){
        // 实现代码
    }
}
```

容器构件，实现访问及管理子节点的方法，

```java
public class Composite implements AbstractElement{
    private List<Component> list = new ArrayList<>();
    void add(Component component){
        list.add(component);
    }
    void remove(Component component){
        list.remove(abstractElement);
    }
    AbstractElement get(int i){
        list.get(i);
    }
    // 遍历其叶子节点
    void method(){
        for(Component component : list){
            component.operation();
        }
    }
}
```









### 组合模式的优缺点

优点：

1. 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次
2. 客户端调用简单，客户端可以一致地使用组合构件或其中的单个对象，用户不必关心自己处理的是的单个对象还是组合对象，简化了客户端代码
3. 定义了叶子对象和容器对象的类层次结构，；复杂的树形结构
4. 更容易在组合体中加入对象构件，客户端不必因为加入了新的对象而更改原有的代码；



缺点：

1. 使设计变更更加抽象，对象的业务规则如果很复杂，则实现组合模式具有很大的挑战
2. 增加新的构件时会产生一些问题，很难对容器中的构件类型进行限定。







### 组合模式分类

#### 透明组合模式

在透明组合模式中，抽象构件 Component 声明了所有用于管理成员对象的方法，所有的构件类具有相同的接口。

- 缺点是不够安全，叶子构件和容器构件是有区别的。

#### 安全组合模式

在安全组合模式中，抽象构件 Component 没有声明所有管理成员对象的方式，这些方法由 Composite 实现，而叶子节点不需要实现这些方法。

- 缺点是不够透明，客户端不能完全针对抽象构件类进行编程



## 4. 装饰模式（待补充）







## 5. 外观模式

> 门面模式
>
> 外观模式中的外观角色类似于控制器，外观角色可以操作一个或多个子系统，实现系统的功能。

通过引入一个外观角色来简化客户端与**子系统**之间的操作，为复杂的子系统调用提供了一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。

### 定义

**外观模式：**为子系统中的接口提供统一的入口。

- 外观模式定义了一个高层接口，这个接口使得子系统更加容易使用。
- 在外观模式中，外部与一个子系统的通信可以通过一个统一的外观对象进行。

外观模式包含以下角色：

1. Facade（外观角色）：
   - 外观角色知道相关子系统的功能和责任
   - 外观角色将错油从客户端发来的请求委托到相应的子系统中。
2. SubSystem（子系统角色）：可以有多个子系统角色
   - 每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；
   - 每一个子系统都能被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；
   - 子系统并不知道外观类的存在，就系统而言，外观角色仅仅是另外一个客户端而已。

> 客户端只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道

### 代码

子系统类代码

```java
// 子系统A
public class SubSystemA{
    public void method(){
        System.out.println("子系统A的方法");
    }
}
// 子系统B
public class SubSystemB{
    public void method(){
        System.out.println("子系统B的方法");
    }
}
```

外观角色类代码

```java
public class Facade{
    private SubSystemA ssa = new SubSystemA();
    private SubSystemB ssb = new SubSystemB();
    
    public vodi method(){
        ssa.method();
        ssb.method();
    }

}
```

客户端代码

```java
public class Client{
    public static void main (String [] args){
        Facade facade = new Facade();
        facade.method();
    }
}
```





### 外观模式的优缺点





















































# 行为型模式

## 迭代器模式

==游标==

迭代器是遍历集合的一种设计

迭代器模式可以将数据的遍历功能从聚合对象中分离出来，聚合角色只负责存储数据，而遍历数据由迭代器来完成，简化了聚合对象的设计，更符合“单一职责原则”的要求

### 定义

**迭代器：**提供一种方法来**访问**聚合对象，而不用暴露这个对象的内部表示。

迭代器模式具有以下角色：

1. Iterator（抽象迭代器）：定义了访问和遍历数据的接口，有以下方法：
   - first()
   - next()
   - hasNest()
   - currentItem()
2. ConcreteIterator（具体迭代器）：实现了抽象迭代器，完成聚合对象的遍历，同时对聚合进行遍历时根据其当前位置。
3. Aggregate（抽象聚合类）：存储对象，并定义创建相应迭代器对象的接口
   - createIterator()
4. ConcreteAggregate（具体聚合类）：实现了创建相应迭代器的接口

### 代码

```java
// 抽象迭代器
public interface Iterator {
	void first();
	void next();
	boolean isLast();
	Object currentItem();
}
```

```java
package iterator.exception;

public class ConcreteIterator implements Iterator{
	Object [] objects;
	private int index;

	public ConcreteIterator(Object[] objects) {
		this.objects = objects;
	}

	@Override
	public void first() {
		index = 0;
	}

	@Override
	public void next() {
		if (index < objects.length){
			index++;
		}
	}

	@Override
	public boolean isLast() {
        // 注意：这里不是object.length - 1;
        // 当遍历到最后一个数据的时候，索引的下标值为object.length - 1;这时还会执行next方法，到object.length 的时候，已经遍历了所有的元素了，指向的位置为空。
		return index == objects.length;
	}

	@Override
	public Object currentItem() {
		return objects[index];
	}
}

```

```java
// 抽象聚合类
public interface Aggregate {
	Iterator createIterator();
}
```

```java
// 具体聚合类
public class ConcreteAggregate implements Aggregate{
	private Object [] objects = {"C","Java","Spring","SpringBoot","SpringCloud","SSM"};
	@Override
	public Iterator createIterator() {
		return new ConcreteIterator(objects);
	}
}
```

```java
public class Client {
	public static void main(String[] args) {
		Aggregate aggregate = new ConcreteAggregate();
		Iterator iterator = aggregate.createIterator();
		while(!iterator.isLast()){
			System.out.println(iterator.currentItem().toString());
			iterator.next();
		}
	}
}
```

### 迭代器模式的优缺点

优点

1. 支持以不同得到方式遍历一个聚合对象。
2. 简化了聚合类（不需要聚合类自己提供遍历的方法）
3. 在同一个聚合上可以有多个遍历。（不同对象成员变量状态不存在关联）
4. 增加聚合类和迭代类很方便，无需修改原有的代码，符合**开闭原则**的要求；

缺点：

由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器，类的个数成对增加，在一定程度上增加的了系统的复杂性。





使用环境：

1. 访问一个聚合对象的内容而无需暴露它的内部表示。
2. 需要为聚合对象提供多种遍历方式。
3. 为遍历不同的聚合结构提供统一的接口。



























## 观察者模式



观察者模式 / 发布-订阅 / 模型-视图 / 源-监听器 / 从属者

> 一个对象行为的改变可能会当导致一个或多个其他与之存在依赖关系的对象的行为发生改变。
>
> **观察者模式用于描述对象之间的依赖关系。**

> 建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象。
>
> - **观察目标：**发生改变的对象
> - **观察者：**被通知的对象
> - **一个观察目标可以对于多个观察者**

>例子:
>
>老师：上课开始讲课（观察目标）
>
>多个学生：听到老师发声就听课（观察者）

### 定义

**观察者模式：**定义对象间的一种一对多的依赖关系，每当一个对象发生改变时，其相关依赖对象jie得到通知并自动更新

>目标类发生改变，由目标类通知方法for循环依次通知观察者集合中的各个观察者
>
>目标类发生改变，通过方法通知各个观察者，观察者也通过方法表示自己也要发生改变

观察者模式包含以下角色

- Subject（目标）：被观察对象，可以是接口，可以是抽象类或实现类
  - 定义了一个观察者集合，存储任意数量的观察者
  - 通过调用具体目标类的`attach`和`detach`将自己从目标类的观察者集合中增加或删除
  - 定义了一个通知方法`notify()`，
- ConcreteSubject（具体目标）：目标类的子类
  - 包含经常发生改变的数据，当他的数据发生改变时，会向它的各个观察者发出通知
  - 实现了目标类定义了抽象业务方法
- Obverse（观察者）：观察者将对观察目标的改变做出反应
  - 一般是接口，声明了更新数据的方法`update()`
- ConcreteObverse（具体观察者）：
  - 维护了一个指向具体目标的引用，存储具体观察者的有关状态。（外界借助观察者来确认目标类是否发生改变，观察者可以在被通知后将目标类的状态输出）
  - 实现了抽象观察者Obverse中定义的更新数据的方法`update()。`

### 代码

```java
// 观察者类（接口） 接口有一个方法，是被通知方法
public interface Obverse{
    public void response();
}
```

```java
// 目标类（抽象类）
public abstract class Subject{
    // 维护一个观察者集合，一个目标类可以有多个观察者，当目标对象发生改变时，会通知集合中的各个观察者
    List<Obverse> obverses = new ArrayList();
    // 向观察者集合中添加新的观察者
    public void attach(Obverse obverse){
        obverses.add(obverse);
    }
    // 从观察者集合中删除某一各观察者
    public void detach(Obverse obverse){
        obverses.remove(obverse);
    }
    // 通知观察者的方法
    public abstract void notify();
}
```

```java
//具体目标类：继承了目标类(需要实现继承类的抽象方法)
public class ConcreteSubject extends Subject{
    public void notify(){
        // 行为发生改变时直接调用即可
        for(Obverse obverse : obverses){
            //行为发生改变，调用每一个观察者的相关方法，使其产生响应
            Obverse.response();
        }
    }
}
```

```java
//具体观察者类：实现了观察者接口，具体观察者可以有多个
public class ConcreteObverse implements Obverse{
    public void resopnse(){
        System.out.println("为目标类的行为发生改变而做响应");
    }
}
```

```java
public class Client{
    // 观察者对象
    Obverse obverse = new ConcreteObverse();
    // 目标类对象
    Subject subject = new ConcreteSubject();
    // 将观察者加入目标类，一个目标类可以有多个观察者
    subject.attach(obverse);
    // 假设目标类发生改变，通过与之关联的各个观察者。
    subject.notify();
}
```

### 观察者模式的优缺点

优点：

- 在观察者和观察目标之间建立一个抽象的耦合，维护了一个观察者集合
- 广播通信：简化了一对多系统设计的难度（for循环类似于广播通信）
- 符合开闭原则，新加具体观察者不需要修改原有的系统代码，新增观察者目标也很放方便（具体观察者和观察目标之间不存在关联关系的情况下）

缺点：

- 通知一个目标的多个观察者需要花费时间（如果有）
- 目标和观察者存在循环依赖，可能会出现死循环，导致系统崩溃。
- 观察者只知道观察目标发生了改变，但是不知道观察目标怎么发生了改变。



适用场景：

- 一个对象的改变将导致其他一个或多个对象发生改变，而不需要知道有多少各对象会发生改变，可以降低对象后之间的耦合
- 一个对象必须通知其他对象，并不知道这些对象具体是谁
- 可能会有触发链：A发生改变  --->A 通知B，B发生改变---->B通知C，C发生改变。。。。。。













## 状态模式/状态对象

> 例子
>
> 学生：
>
> - 开心 -> 学习 （状态 -> 行为）
>
> - 不开心 -> 打游戏
>
> 学生在不同的状态下具有不同的行为；

> 状态模式用来解决**复杂对象的状态转换以及不同状态下行为的封装问题**。
>
> 使对象在不同的状态下具有不同的行为，需要将对象的状态从该对象中分离出来

#### 定义

**状态模式：**允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。



状态模式包含以下角色：

- Context（环境类）

  - 是拥有状态的对象，状态存在多样性且在不同状态下的行为可能不同
  - 维护了一个抽象状态类的实例，定义了当前状态

- State（抽象状态类）

  - ### 

- ConcreteState（具体状态类）





## 策略模式/政策模式

**策略：**解决问题的方法

>例子：
>
>出行方式选择：
>
>- 下雨：开汽车
>- 晴：骑自行车（开源节流）
>
>不同环境（天气）选择的出行方式不一样，即选择根据环境选择恰当的策略

### 定义

**策略模式：**定义一系列算法，将每个算法封装起来，并让它们可以互相转换。让算法独立于使用它的客户而改变

策略模式用于**算法的自由切换和扩展**。根据**环境从算法组中选择某一种算法。**

策略模式允许：用户选择一个方法（算法/策略）解决某一问题，同时可以方便的切换算法或者新加算法

策略模式的**目的**：将算法的定义和使用分开；（符合“类的单一职责原则”）

策略模式具有以下的角色：

- Context（环境类）：使用策略完成业务功能的类
  - 需要维护一个对抽象策略类的引用实例，用来定义所采取的策略，设置抽象策略类的运行类型；
- Strategy（抽象策略类）：为所支持的策略（解决问题的方法）提供了抽象方法，可以是抽象类，也可以是接口；
- ConcreteStrategy（具体策略类）：实现了抽象策略类的算法（如何去解决问题），用来覆盖在环境类中定义的抽象策略类实例对象。

> 可以有多个具体策略类

### 代码

**没有策略模式之前代码如下：**

```java
public class Context{
    public void selectStrategy(strategy){
        //使用多重条件转移语句
        if(strategy.equal("strategyA")){
            //策略 A 的具体代码	或者策略 A 的方法
        }else if(strategy.equal("strategyB")){
            //策略 B 的具体代码	或者策略 B 的方法
        }else{
            //策略 X 的具体代码	或者策略 X 的方法
        }
    }
}
```

> 每一次新加策略都要改变原有的代码，不符合开闭原则；
>
> 算法的**定义**和**使用**都在同一个类中，不符合类的单一职责原则。

**选择策略模式：**

策略模式的三个主要角色：环境类、抽象策略类、具体策略类

```java
//抽象策略类 可以是抽象类，也可以是接口
public interface Strategy{
    // 该策略类具有什么方法
    void strategyMethod();
}
```

```java
//具体策略类 实现了抽象策略类，重写了抽象策略类的方法  	可以有多个抽象策略类
public class StrategyA implements Strategy{
    @Override
    public void strategyMethod(){
        //实现代码
    }
}

public class StrategyB implements Strategy{
    @Override
    public void strategyMethod(){
        //实现代码
    }
}
```

```java
// 环境类 维护了一个抽象环境类实例，可以通过setter方法对该实例进行初始化，通过该实例调用其方法
public class Context{
    private Strategy strategy;
    public void setStrategy(Strategy strategy){
        this.strategy = strategy;
    }
    public void stratrgy(){
        strategy.strategyMethod();
    }
}
```

> 由上述采用策略类的代码可见，避免了多重条件转移语句，将策略的定义抽取出来单独形成一个类，通过setter放在需要的地方注入，实现**复用**，新加策略只需要新增策略类，不需要修改源代码；
>
> 注意：策略类的**数量**有时候会过多

```java
//客户端调用策略类选择恰当的策略
public class Client{
    public static void main(String [] args){
        Strategy strategy;
        strategy = (Strategy) XMLUtils.getBean(); //外界提供策略类的类型，通过反射得到策略类的类型
        // 环境类
        Context context = new Context();
        // 通过 setStrategy() 方法，设置当前环境的对应的策略
        context.setStrategy(strategy);
        // 执行策略
        context.strategyMethod();
    }
}
```

> 由此可见，客户端需要知道所有的具体策略类，才能选择恰当的策略，而且只能选择一种策略，选择另一种策略时会将上一种策略覆盖。



> 抽象策略类 -> 具体策略类 -> 环境类 -> 客户端



``` 
外界通过影响环境而影响策略的选择
```

### 策略模式的优缺点

优点：

1. 提供了对“开闭原则”的完美支持：在不修改源代码的情况下，可以灵活地添加新的策略类；
2. 提供了管理相关算法组的办法：抽象策略类将所有的公共代码抽取出来；
3. 提供了可以替代继承关系的办法：通过策略类的实例对象便可以选择算法；
4. 可以避免使用多重条件转移语句：if(a) 算法A else if(b) 算法B else 算法C；
5. 提供了算法复用机制，不同环境可以方便使用策略类；

缺点：

1. 客户端必须知道所有的策略类，并自行决定使用哪一种策略类；
2. 策略模式将造成很多策略类和对象
3. 无法在客户端使用多个策略类

适用环境：

1. 动态地让一个对象在多种行策略中选择一种策略；
2. 一个系统需要动态地在几种算法中选择一种；
3. 避免难以维护的多种条件选择策略的语句；
4. 不希望客户端知道复杂的、与算法相关的数据结构，只在在具体策略类中封装算法和相关的数据结构，提高算法的保密性和安全性




> 注意：简单工厂模式不是23种设计模式中的

创建型（创建对象）：单例模式、原型模式、工厂方法模式、建造者模式、抽象工厂方法模式

结构型（类或对象之间的**组合**）：代理模式、适配器模式、组合模式、装饰模式、外观模式  | 桥接模式、享元模式

行为型（类或对象怎么**交互**）：命令模式、解释器模式、迭代器模式、观察者模式、状态模式、策略模式 | 职责链模式、中介者模式、备忘录模式、模板方法模式、访问者模式

