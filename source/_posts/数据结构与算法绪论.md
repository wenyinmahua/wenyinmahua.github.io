---
title: 数据结构与算法绪论
comments: true
category: 数据结构与算法
tags:
  - 408
cover: https://tse4-mm.cn.bing.net/th/id/OIP-C.-Gua19mx8sZHc4Y_bxaATQHaEK?w=308&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---



# 数据结构与算法绪论

## 基本概念

### 1.基本概念与术语

#### 1.1 数据

> 数据（data）是描述客观事务的各种信息的载体。
>
> data：数据、资料、信息、材料

计算机里面用来描述客观事物的属性的值的数、字符及能输入到计算机中并被计算机识别和处理的符号的集合，计算机领域称之为`数据`。

比如说，使用 Excel 文件保存一个人的信息。一个人的信息有`姓名`、`年龄`、`出生日期`等等，姓名使用字符来标识，比如“Lisi”或者“李四”，年龄使用数字来表示，比如 21，出生日期使用日期格式的数据来标识，比如 2003-01-01。这些信息保存在计算机中，我们称之为数据。



#### 1.2 数据元素

> 数据元素（data elements）是数据的基本单位，由若干个数据项（data itema）组成。
>
> element：元件、要素、原理、成分。
>
> item：条目、项目、条款。（与其这些翻译，我更愿意翻译为“组成元素之一”）

如 Excel 中，保存一个人的信息，有`姓名`、`年龄`、`出生日期`等等，其中的姓名、年龄、出生日期等都是一个个 data item（数据项），具体的 item 组成了 element，即 `“Lisi”、21、2003-01-01` 组成了一个数据元素。



#### 1.3 数据对象

> 具有相同类型的数据元素（elements）的集合指的就是数据对象（data objects）
>
> 数据对象是数据的一个子集。



#### 1.4 数据类型

> 数据类型（data type）：数据类型不单单指的是这个数据的值可以是什么，还指的是这个值能进行什么操作，比如常识中的整型（整数）可以进行加减乘除等操作。
>
> 数据类型是**一个值的集合和定义在此集合上的一组操作**的总称。

- 原子类型（atomic type）：原子意为不可分割（理工科同学都知道，原子是指化学反应中不可再分的基本微粒，这里借其意表示不可再分），原子类型意味着这个类型的数据不能进一步细分了。原子类型可以组成复杂的结构类型。

  - 比如整数，还能继续划分吗？还能划分成什么？答案是不能划分了，如果你说能划分成（负整数、0、正整数），那么不好意思，不是这样划分的，因为它们的值都是数字。
  - 整数，字符类型（英文、中文）等等都是原子类型。

- 结构类型（structure type）：结构类型的数据由原子类型的数据组成，同时，结构类型也能组成更加复杂的结构类型。

  - Excel 中，一个人的信息是由姓名、年龄、出生日期等等原子类型的数据组成的结构类型。

- 抽象数据类型（abstract data type）：需要了解 abstract 的英文

  > abstract：
  >
  > - v. 提取、抽取、把...抽取出、分离（关键）
  > - n. 抽象派艺术作品
  > - adj. 抽象的、纯理论的
  > - 摘要、文摘、英文摘要

  - 抽象数据类型我更愿意称之为模板（template）数据类型，挺抽象的解释不出来，哈哈哈。
  - 言归正传，抽象数据类型用于描述数据对象及其操作，
  - 为什么我称之为模板数据类型呢？
    - 原因在于其`抽象`、关键在于`提取`，抽象数据类型用于描述一系列具有相同特性的数据，比如之前提到人都具有姓名、年龄、出生日期等等属性，他们可以提取成一个数据类型，但是它的值可以为 `“Lisi”、21、2003-01-01` ，也可以为 `“zhangsan”、22、2004-12-12` ，抽象数据类型提供了一个模板，允许你去创建不同的数据实例，当然可以也提供一些操作允许你去修改其值。

一张图片（毕加索的画作）让你了解什么叫做抽象

![毕加索抽象](https://tse4-mm.cn.bing.net/th/id/OIP-C.TxIehoArUHBMaaYsud7y7AHaKx?w=143&h=208&c=7&r=0&o=5&dpr=1.3&pid=1.7)



> ❓那么抽象数据类型和结构类型有啥区别吗？
>
> 定义了一个抽象数据类型“猫”，含有姓名、年龄、出生日期等等元素，同时定义了一个含有相同元素的抽象数据类型“狗”，这里的“猫”和“狗”虽然不是同一抽象数据类型，但是它们是同一结构类型。
>
> - **结构类型**关注的是对象的结构和接口，而不是对象的类型名称。（关注的不是这个类型叫什么，关注的是其组成是一样的，比如都有姓名、年龄、出生日期）
> - **抽象数据类型**是一种数学模型，用于描述数据对象及其操作。它强调的是数据的逻辑视图（怎么表示）和行为（能干什么），而不是具体的实现细节。



#### 1.5 数据结构

数据结构（data structure）：相互之间存在一种或多种特定关系的数据元素（element）的集合。

数据结构结构包含三个：逻辑结构、存储结构和数据运算。

##### 逻辑结构

逻辑结构描述了数据元素之间的逻辑关系，分为线性结构和非线性结构。

![逻辑结构分类图](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111202656553.png)



线性关系通常指的是数据元素之间按照一定的顺序排列，每个元素最多只有一个前驱和一个后继。

![链表](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111203313469.png)

非线性关系通常指的是数据元素之间的关系不是简单的顺序排列，一个元素可能有多个前驱或后继。

![树](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111203541183.png)

##### 存储结构

存储结构指的是在计算机中存储的表示，也成为物理结构，是用计算机语言实现的逻辑结构。主要有顺序存储、链式存储、索引存储、散列存储。

> 了解计算机存储
>
> 计算机用来存储数据的，那么，外存为 256GB 的计算机，使用的只剩下 10GB，我想下载一个30 GB 的游戏，那么至少要卸载 20 GB 的其他内容，腾出空间来安装我的游戏。那么会出现这种情况：
>
> 图中 1 表示这篇空间已经被使用了，那么三块空白的地方确实能放 30GB 的内容，但是不连续，这个时候，怎么使用这样的空间存放下 30 GB 的游戏呢？要不把这个游戏数据分开，分成两部分，一部分20GB，存在前面 2 个连续的格子中，另外一个存在最后一个格子中，只需要告诉系统这俩部分是一个整体不就行了吗，恭喜你，想到了链式存储。
>
> ![内存占用](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111205222609.png)

**顺序存储**指的是逻辑上相邻的元素在**存储在物理位置上也相邻的存储单元**中。

- 优点：可以实现随机存取
- 缺点：只能使用相邻的一整块存储单元，可能会产生外部碎片。



**链式存储：**不要求逻辑上相邻的元素在物理上也相邻，借助表示元素的存储地址的指针来表示元素之间的关系。

- 优点：不会出现内存碎片，可以充分利用所有的存储单元
- 缺点：存储数据的同时还要存储指针的信息（下一个元素在哪个存储单元），需要占用额外的空间。



**散列存储（哈希存储）：**根据元素的**关键字**直接计算出该元素的存储地址。

- 优点：检索、增加和删除数据很快
- 如果散列函数不好，则可能会出现存储单元的冲突（称之为哈希冲突），解决冲突还需要增加时间和空间开销。



**索引存储：**在存储数据信息的同时，还建立附加的索引表。

- 优点：检索速度快
- 缺点：附加的索引表需要占用额外的存储空间，增加、删除元素需要修改索引表，需要时间开销。



如果某台计算机中的外存的使用情况如下图所示，如果想继续使用下一个数据想要五个存储单元

<img src="https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111211159352.png" alt="存储结构" style="zoom: 50%;" />

如果使用**顺序存储**存储，结果如图所示，如果想继续存储需要五个或者五个以上存储单元的数据，似乎存放不下去了，其他没用被使用的存储单元，我们称之为**内存碎片**，又小又不能用。

<img src="https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111211438086.png" alt="顺序存储" style="zoom: 50%;" />

如果使用**链式存储**，结果如下，可以看出，即使不使用连续的空间，也能存放 5 个存储单元的数据了，不过需要指针指明它们之间的关系，这就是链式存储，不会出现内存碎片问题，但是指针会占据一点空间。

<img src="https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111211839901.png" alt="image-20241111211839901" style="zoom:50%;" />

**散列存储/哈希存储**根据关键字（假设为存储的值）来确定存储的位置。

![image-20241111212928046](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241111212928046.png)



##### 数据的运算

施加在数据上的运算包括运算的定义和实现，对这个数据干什么，存还是取，进行什么运算？

- 运算的定义是针对逻辑结构的，指出运算的功能；

- 运算的实现是针对存储功能的指出匀速那的具体操作步骤。



## 算法和算法的评价

### 算法的基本概念

> 如果想让计算机求两数之和，就要编写一短简单的代码让计算机完成计算，这段简单的代码解决了两数值和的问题，这就是算法。

算法是对特定任务求解步骤的一种描述，是指令的有序序列，其中的每条指令代表一个或多个操作。

算法的五个重要特性：

1. 有穷性：一个算法必须执行一定次数后结束（如递归算法），且每一次都可在有穷的时间内完成。如果一个算法陷入了死循环，一直拿不到结果，那么这个算法基本上没有任何意义了。
2. 确定性：算法中的每一条指令必须由确切的含义，对于相容的输入只能得到相同的输出。
3. 可行性：算法中描述的操作都可以通过硬件实现的基本运算执行有限次来实现。
4. 输入：一个算法有零个或多个输入，这些输入取自于某个特定对象的集合。
5. 输出：一个算法有一个或多个输出，这些输出与输入有着某种特定关系的量。算法主要是为了解决高效问题，如果没有输出，怎么知道算法解决问题的结果。

比如求两数之和：

```C
#include<stdio.h>
int sum(int a,int b);
int main(){
	int a;
	int b;
	int c;
	scanf("%d",&a); // 输入
	scanf("%d",&b); // 输入
	c = sum(a,b);
	printf("%d 与 %d 的两数之和的结果%d",a,b,c); // 输出
}
int sum(int a ,int b){
	return a + b; // 具有明确的含义，返回 a+b ，只执行一次
}
```

定义了一个算法 `sum` ，算法的输入为参数 a 和 b，输出为返回的 `a+b` 的结果，执行一次便可拿到结果。

输入 a = 2, b = 3, 返回 5；输入 a = 3, b = 3, 返回 6；输出和输入有着特定的关系。满足了上面提到的五个特性。



### 算法效率的度量

如何评价算法的效率呢？

算法效率的度量通过**时间复杂度**和**空间复杂度**来描述。



#### 时间复杂度

**时间复杂度**描述的是算法运行时间随输入数据规模 n 增长的趋势。具体来说，它关注的是算法中基本操作（如赋值、比较、算术运算等）的执行次数与输入规模 n 之间的关系。时间复杂度通常用大O符号（Big O notation）来表示，形式为 $T(n) = O(f(n))$ ，其中 $f(n)$ 描述了算法中基本运算的频度。

如下所示：

```java
#include<stdio.h>
int main(){
	int n;
	scanf("%d",&n);
	int sum = 0;
	for(int i = 0; i < n; i++){
		sum += i; // 这条语句的执行次数和数据规模 n 有关，
	}
	printf("%d",sum);
}
```

这个算法的运行时间会随着 n 变化而变化，时间复杂度为 $O(n)$

```java
for(int i = 0; i < 10; i++){
    sum += i;
}
```

这个算法中将原来的 n 替代成一个常数，这里的运行时间基本上不会发生增长，所以说这里的时间复杂度为 $O(1)$，即为常量级时间复杂度。

- 最坏时间复杂度：指的是在最坏的情况下，算法的时间复杂度
- 最好时间复杂度：指的是在最好的情况下，算法的时间复杂度
- 平均时间复杂度：指的是所有可能输入实例在等概率出现的情况下，算法的期望运行时间。



**时间复杂度运算规则：**

- 加法规则：$T(n) = T_1(n) + T_2(n) = O(f(n)) + O(g(n)) = O(max(f(n),g(n)))$
- 乘法规则：$T(n) = T_1(n) * T_2(n) = O(f(n)) * O(g(n)) = O(f(n)*g(n))$

常见的渐近时间复杂度排序：

> $O(1) < O(log_2n) < O(n) < O(nlong_2n) < O(n^2) < O(n^3) < O(2^n) < O(n!) < O(n^n)$

<img src="https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241112190727221.png" alt="时间复杂度趋势图" style="zoom:67%;" />

时间复杂度为$O(log_2n)$的算法：

```C
for(int i = 0; i < n; i*=2){
    sum += i;
}
```



时间复杂度为$O(n)$的算法：

```C
for(int i = 0; i < n; i++){
    sum += i;
}
```



时间复杂度为$O(nlog_2n)$的算法：

```C
for(int i = 0; i < n; i*=2){
    for(int j = 0; j < n; j++){
        sum += 1;
    }
}
```



时间复杂度为$O(n^2)$的算法：

```C
for(int i = 0; i < n; i++){
    for(int j = 0; j < n; j++){
        sum += 1;
    }
}
```



















