---
title: 面试题总结
date: 2024-05-20
updated: 2024-09-05
comments: true
category: 面试
password: m030109
abstract: Here's something encrypted, password is required to continue reading.
message: Hey, password is required here.
wrong_pass_message: 密码错误 no! You know.
---

# 面试题总结

# Java基础篇

- *2 最快的方式是移位 （无符号右移、带符号右移）
- NoSuchMethodError 一般是 jar 包冲突了

- Java 只有值传递，没有地址传递，对象的传递就是把引用关系传递了（副本）
- char 可以存放中文
- UUID 全局唯一标识符：由 32 位16 禁止数标识，共有128位 （8-4-4-4-12）
  - 由 MAC 地址、时间戳、随机数等信息生成
- 一定要自定义一个无参构造器。
  - 反射和序列化要求
  - JavaBean 规范
  - 子类构造器的默认行为

- JDK = JRE + 开发和调试 Java 程序的工具（javac、javap、java、jar、javadoc）
- JRE = 环境（JVM ） + 类库 
- 字节码：Java 源代码经过编译后的代码，JVM 加载字节码文件，之后通过解释器逐行解释执行。
- JDK 9 引入了一种新的编译模式 AOT，会在代码执行前将其编译成机器码，避免了 JIT 预热等各方面的开销，提高 Java 程序的启动速度，减少内存占用，增强 Java程序的安全性



## 0. 面向对象三大特征

#### 1. 封装

封装就是把一个对象的状态信息（属性）隐藏在对象的内部，不允许外界直接访问这个属性，而是通过一些公开的方法，让外界来进行操作

#### 2. 继承

使用已存在的类的定义作为基础建立新类的过程，新类的定义可以增加新的数据或新的功能，也可以用父类的功能。提高代码的复用率。

- 子类拥有父类对象的所有的属性和方法，但是不能访问不父类的私有方法和属性
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展
- 子类可以使用自己的方式实现父类的方法。

#### 3. 多态

一个对象具有多种状态，**父类引用指向子类实例**

- 有继承和实现关系
- 引用类型的变量发出的方法调用到底是哪个类中的方法，只能在运行时确定
- 多态不能调用只在子类存在但是不在父类存在的方法
- 子类重写了父类的方法，正真指向的是子类重写的办法，如果子类没有重写，那么执行的就是父类的方法。



### 1. Java 和 C++ 的主要区别 

- 面向对象
- 编译型与解释型
- 跨平台（平台无关：字节码+JVM）、内存管理（自动内存管理和垃圾回收）、参数传递方式（值传递）、多继承（不支持，菱形继承问题、变得庞大、难以理解和维护，修改父类代码会邮箱子类）、系统资源的机制能力（弱）
- 没有指针



### 2.接口 和 抽象类的区别

接口和抽象类都可以用来实现抽象层。

|            | 接口                                                        | 抽象类                                 |
| ---------- | ----------------------------------------------------------- | -------------------------------------- |
| 定义       | interface                                                   | abstract class                         |
| 方法定义   | 只有抽象方法，没有实现的方法（除了default）JDK9之后 private | 都有                                   |
| 修饰符     | 只有 public（默认）                                         | public、protected、private、默认       |
| 构造器     | 无                                                          | 有                                     |
| 成员变量   | 只能是public static final 类型，不能修改且必须有初始值      | 可以有任何修饰符，可以被重新定义和复制 |
| 继承和实现 | 一个类可以实现多个接口                                      | 一个类只能继承一个抽象类               |
| 职责       | 制定规范                                                    | 复用                                   |

- 单继承、多实现
- 抽象了具有构造器不能被实例化，但其构造器起到初始化共有成员变量、强制初始化操作等作用。
- 定义标准、规范使用接口，复用代码使用抽象类



### 3.多态

多态：同一操作作用于不同的对象，可以有不同的解释，不同的结果。

多态需要满足的三个条件：

- 有类继承或接口实现
- 子类重写父类方法
- 父类引用指向子类对象。



### 4.包装类

#### 1. 基本类型与包装类

- 很多的地方需要对象而不是基本数据类型，如集合类；
- 让基本类型具有对象的特征，添加了属性和方法，丰富了基本类型的操作。

区别：

- 默认值不同
- 初始化方式不同（一个需要 new）
- 存储方式不同（基本类型（局部变量保存在栈上，成员变量保存在队中）包装类随对象保存在堆上）
- 占用空间不同
- 比较方式不同



#### 2. 自动装箱和拆箱

装箱：就是把基本类型进行包装，包装成包装类过程。

拆箱：就是把包装类转换成基本数据类型的过程。

自动装箱通过包装类的`valueOf()`，自动拆箱通过包装类对象的`xxxValue()`



#### 3. 存储金额

金额使用 `BigDecimal` 来存储，因为 double、float 在计算时会出现精度丢失问题，引起资损问题。浮点数只是近似值而不是精确值，因为有些小数无法直接使用二进制表示，从而使用近似值表示。

不推荐使用 Long，（金融的费率、利率、服务费的费率等等一般都是万分之几或千分之几）



#### 4. BigDecimal 使用注意事项

不要使用 equal 对比两个 BigDecimal 对象，而是使用 `conmpateTo` 方法。因为 equal 对比两部分内容（值 + 标度）



#### 5.包装类的缓存机制

Byte、Short、Integer、Long[-128,127]

Character [0,127]

Float、Double 都没有缓存机制



自动装箱和new 出来的包装类不相等。



### 5. String

**字符串常量池**是 JVM 为了提升性能和减少内存消耗针对字符串专门开辟的一块区域，主要目的是为了避免字符串的重复创建

- 字符串常量池中的常量有两种来源
  - 编译期进入 Class 常量池，运行期进入字符串池
  - 运行期通过 intern 方法将字符串对象手动添加到字符串常量池中。
- JDK 9 之前，不要在 for 循环里面进行 + 字符串拼接操作
  - JDK 9 引入了 StringConcatFactory 代替 StringBuilder，将字符串拼接延迟到运行时



#### 1. String 的不可变性

- 存储值的 char 数组使用 `final` 修饰了，一旦数组被初始化，就不能指向其他数组。
- String 类也被 `final` 修饰了，不能被继承，里面的方法不能被重写。
- `没有提供修改字符串内容的公共方法`，对字符串进行修改，会创建一个新的 String 对象。

> String 对象的值改变了是因为返回了一个新的对象

为什么要设计成不变的？

如果可变，s1 和 s2 都会指向同一个地址，修改 s1 也会导致 s2 被修改

- 缓存：大量的字符串的创建非常消耗内存，节省堆空间，提高字符串性能
- 安全性：用于存储敏感信息，不可变具有安全性
- 线程安全：可以被同时运行的多个线程之间共享



#### 2. String s = new String("mahua"); 会创建几个对象？

会创建 1 个或 2 个对象

每一次 new 一定会在堆上创建一个对象，另外一个对象要判断常量池里面有没有这个字符串常量，如果没有，就创建字符串常量引用指向的对象。



```java
String s1 = "hello";
String s2 = "world";
String s3 = s1 + s2; // 这个常量池池里面只有 s1 和 s2 的字面两量，没有 helloworld。
String s4 = "hello" + "world"; // 常量池里面只有一个 helloworld；
String s5 = "helloworld"; // s4 = s5;都指向同一个字符串对象，因为编译时会直接合在一起。
```

如果在字符串拼接中，有一个参数是非字面量（变量），整个拼接操作会被编译成StringBuilder.append，这种情况下，编译器无法知道气质的。

#### 3. String 有长度限制

并且编译期和运行期不一样。

编译期是 65535；

运行期是 $2^{31}-1$ int 的最大值，因为其长度使用 int 表示 



#### 4. intern

intern 方法可以运行期向运行时常量池中增加常量。

- 将字符串字面量放入常量池（如果池没有的话）
- 返回这个常量的引用。



#### 5. String、StringBuilder、StringBuffer 的区别

|          | String   | StringBuilder | StringBuffer             |
| -------- | -------- | ------------- | ------------------------ |
| 是否可变 | 不可变   | 可变          | 可变                     |
| 线程安全 | 线程安全 | 非线程安全    | 线程安全（同步锁的存在） |

StringBuilder 和 StringBuffer 使用数组保存字符串，但是没有使用 final 和 private 修饰符修饰。提供了修改字符串的方法，比如 append、insert



#### 6. JDK 9 用了 byte 数组

使用 char 每个字符使用两个字节，

使用了 byte 每个少于 8 字节的字符占用一个字节，超过 8 位就继续使用UTF-16 与字符数组。







### 6.泛型

#### 1. 什么是泛型，有什么好处？

泛型：允许在定义类或接口的时候使用类型参数。声明的参数在使用的时候使用具体的类型替换。通过类型擦除的方式来实现的。

- 方便，提高代码的复用性；可读性以及稳定性
- 安全，在编译期做类型检查。

可以通过反射来在 ArrayLis 中存放不同类型的数据

```java
public class ReflectionTest {
    public static void main(String[] args) throws InvocationTargetException, IllegalAccessException, NoSuchMethodException {
       List<Integer> list = new ArrayList<>();
       Method method = list.getClass().getMethod("add", Object.class);
       method.invoke(list,"java");
       System.out.println(list.get(0));
    }

}
```





### 7. 语法糖

语法糖主要是编程语言为了方便开发人员使用而设计的一种特殊语法，编译期会转换成基本语法结构。（JVM不能识别语法糖）

- switch 支持 String 与 枚举 通过 hashCode 和 equals 方法实现；
- 泛型：类型擦除
- 自动装箱与拆箱
- 方法变长参数
- 增强 for 循环
- try-catch-resource
- lambda
- 枚举
- 内部类



### 8. 反射

#### 1. 什么是反射？

反射就是程序在运行时能够获取自身的信息。

- 在运行时判断任意一个对象所属的类；
- 在运行时判断任意一个类所具有的成员变量和方法；
- 在运行时任意调用一个对象的方法（私有方法也可以）
- 在运行时构造任意一个类的对象。



#### 2. 反射优点与缺点

优点：让代码更加林火，为各种框架提供了开箱即用的功能提供了遍历。

缺点：

- 代码可读性低及可维护性
- 反射代码执行的性能低
- 反射破坏了封装性



#### 3. 为什么反射慢？

- 反射涉及动态解析的类型，不能执行某些 JVM 优化（JIT优化）
- 使用反射时，要对参数解析包装（Object），和拆包（具体类型），消耗时间
- 反射调用方法时会从方法数组中遍历查找，还要检查可见性，耗时。
- 不仅检查方法的可见性，也会检查参数。







### 9. 类的细节

#### 1. Java 创建对象的几种方法：

- new
- 反射
- 克隆
- 反序列化



#### 2. 成员变量和局部变量的区别

|          | 成员变量               | 局部变量         | 共同点        |
| -------- | ---------------------- | ---------------- | ------------- |
| 语法     | 类，能有修饰符         | 代码块，有修饰符 | 都 final 修饰 |
| 存储方式 | 堆                     | 栈内存中         |               |
| 生存时间 | 随对象                 | 随方法           |               |
| 默认值   | 可以没有（final 除外） | 必须有           |               |



#### 3.构造方法：

一个类如果没有显式定义构造方法，那么会自动添加一个无参构造方法

构造方法的特点：

- 名称与类名相同
- 没有返回值
- 自动执行
- 不能别重写，但是能重载





### 10.代理

**代理模式：**使用代理对象来替代对真实对象的访问，在不修改目标对象的前提下，提供额外的功能，**扩展目标对象的功能**。

#### 静态代理

对于目标对象的每个放的的增强都是手动完成的，非常不灵活（接口新增了方法之后，目标对象和代理对象都需要进行修改）而且麻烦（需要对每个目标类都单独写一个代理类）

步骤：

- 定义一个接口和实现类
- 创建一个代理类同样实现这个歌接口
- 将目标对象注入到代理类中，在代理类的对应方法中调用目标类中的对应的方法，对其进行增强。



#### 动态代理

**更灵活：**不需要针对每个目标类都单独创建一个代理类。

> 动态代理是在运行时动态生成类字节码，加载到 JVM 中。

实现动态代理的两种方式：

1. JDK 动态代理：通过反射来接收被代理的类，要求被代理的类必须实现一个或多个接口
2. Cglib 动态代理：通过继承的方式做动态代理（这个类不能被 final 修饰）第三方代码生成库，运行时在内存中动态生成一个子类对象从而实现对目标功能的扩展。



#### JDK 动态代理

JDK 动态代理机制中的 `InvocationHandler` 接口和 `Proxy` 类是核心。

Proxy 类中有一个使用频率最高的方法：`newProxyInstance` 方法，这个方法用来生成一个代理对象。有三个参数：

- loader：类加载器，用于加载代理对象
- interfaces：被代理类实现的一些接口
- h：实现了 InvocationHandler 接口的对象

```java
public Object getProxy(){
    return Proxy.newProxyInstance(Thread.currentThread().getContextClassLoader(),targer.getClass().getInterfaces(),this);
}
```







## 11. 注解

Java 的注解是一种标识，用来标识一个类或者一个字段，提供某些信息供程序在编译或者运行时使用，常常和反射，AOP结合起来使用。不直接影响代码的执行。



#### 元注解

元注解：定义其他注解的注解

- @Target（用在什么地方）
- @Retention（在什么级别保留该注解信息）
- @Documented（将此文档包含在 javadoc 中）
- @Inherited（允许子类继承父类的注解）



#### 注解的解析方法：

注解只有被解析后才会生效，常见的解析方式有两种：

- 编译器直接扫描：@Override
- 运行期通过反射处理：Spring 的 @Value、@Component



## 12. 序列化与反序列化

**持久化**

Java对象一般保存在 JVM 堆里面。

序列化就是将 Java 对象转换成可传输格式的过程，是一种持久化手段。网络传输，存道硬盘中。

通过对象序列化，可以把对象的状态保存为字节数组，并且可以在有需要的地方将这个字节数组通过反序列化的方式再转换成对象。

- 必须需要实现 Serializable 接口
- 不能保存静态变量，使用 `static`修饰的变量，serialVersionUID 除外
- 反序列化需要 serialVersionUID 版本号保持一致
- `transient` 控制变量的序列化，使用其修饰字段，该字段将不会序列化，反序列化时，该字段为类型的默认值。
- 想序列化父类，那么父类也要实现 Serializable 接口



#### JDK 序列化缺点

- 不支持跨语言调用
- 性能差：序列化后字节数组体积更大、传输成本更大。
- 存在安全问题：恶意输入

其他序列化工具：Hession、Kryo、Protobuf、ProtoStuff 等







## 13. 异常

- 不要把异常定义为静态变量，会导致异常栈信息错误。即每次都手动抛出异常，需要 new 一个异常对象抛出
- 抛出的异常一定要有意义
- 避免重复日志
- 建议抛出更加具体的异常

#### 1. Exception 和 Error 有什么区别

Exception 和 Error 的公共祖先是 Throwable

- Exception：程序本身可以处理的异常，通过 catch 进行捕获
- Error：程序无法处理的异常，不建议通过 catch 捕获，如 虚拟机运行错误、虚拟机内存不够错误、类定义错误



#### 2. 异常分为哪两类

- 受检异常（编译时异常 throw Exception、多是IO）通过 catch 或 throws 解决，否则无法通过编译
  - IO 相关异常、ClassNotFoundException、SQLException

- 非受检异常（运行时异常，继承自 RuntimeException）
  - 空指针、数组越界、非法参数、类型转换、算数错误



- RuntimeException 不需要显式 throws
- catch 的时候，先从子类开始 catch

#### 3. 异常处理的关键字

- try：用来指定一块预防所有异常的程序，用来捕获异常，后面要有0个或多个 catch，没有的话，必须有 finally 块
- catch：紧跟在try后面，指定想要捕获的异常的类型，处理 try 块捕获的异常
- finally：保证一段代码在发生什么异常（无论是否捕获或处理异常）情况下都会被执行
- throw：语法用来明确抛出异常
- throws：用来声明一个方法可能抛出的各种异常。



#### 4. finally中的代码一定会执行吗？

**被执行的前提：**

- 对应的 try 语法块被执行
- 程序正常运行

**不会导致 finally 执行的情况：**

- System.exit()
- Runtime.getRuntime().halt()
- try 或 catch 中有死循环
- 虚拟机挂了
- 关闭CPU
- 线程挂了



#### try、catch、finally 的返回值问题

- 不要在 finally 语句块中使用 return

关于 try 和 catch 以及 finally 中都有返回值，最终的返回结果一定是 finally 的返回结果

如果 finally 块中有 return 语句，则其返回值将是整个 try-catch-finally 结构的返回值。如果 finally 块中没有 return 语句，则 try 或 catch 块中的 return 语句(取决于哪个执行了)将确定最终的返回值。 



#### 3. 自定义异常

自定义异常只需要继承 Exception 的子类即可





## 14. 枚举类

枚举类型是由一组固定的常量组成的合法类型，使用 enum 关键字定义一个枚举类型

```java
public enum LanguageEnum {

    JAVA(1,"java"),
    PYTHON(2,"python");

    private int code;
    private String value;

    LanguageEnum(int code, String value) {
       this.code = code;
       this.value = value;
    }
}
```





## 15.SPI 和 API

SPI：服务提供者的接口，专门为服务提供者或者扩展框架功能的开发者区使用的一个接口。

将服务的接口和具体服务的实现分离开，实现服务调用方和服务实现方的解耦，能够提高程序的扩展性、可维护性，修改或替换服务实现而不需要修改调用方。

- Spring 框架、数据加载驱动、日志接口、以及 Dubbo 的扩展实现





## 16. IO

I/O：input/output（以内存为参照物）

#### 1. I/O 流分类

- InputStream/Reader：所有输入流的基类，前者是字节输入流，后者是字符输入流
- OutputStream/Writer：所有输入流的基类，前者是字节输出流，后者是字符输出流

##### 为什么要字节流和字符流？

不管文件读写还是网络发送接收，信息的最小存储单位是字节。

- 字符流是 Java 虚拟机将字节转换得到的，这个过程比较耗时
- 不知道编码类型，使用字节流的过程很容易出现乱码。



#### 3. BIO/NIO/AIO的区别

BIO：同步阻塞I/O，线程发起IO请求之后，一直阻塞，知道缓冲区数据就绪后，再进行下一步操作

- 连接数目比较小且固定的架构

NIO：同步非阻塞I/O，线程发起IO请求之后，不需要阻塞，立即返回，只需要定时轮询IO缓冲区数据是否就绪

- 连接数目多且连接较短的架构（聊天服务）

AIO：异步非阻塞I/O，线程发起IO请求之后，不需要阻塞，立即返回，也不需要定时轮询检查结果，异步IO操作之后会回调通知调用方。

- 连接数据多且连接比较长的架构（相册服务器）



## 17. static关键字

static 可以用来修饰变量、方法、代码块以及类

1. 修饰变量：静态变量
   - 静态变量属于类的本身，而不属于类的特定实例，无论创建多少个对象，只会分配依次内存。
   - 特点：
     - 所有实例共享同一静态变量
     - 在类加载到内存时就被初始化，而不是创建对象的时候
     - 常用于管理类的全局状态或作为常量仓库 使用`public static final`修饰
2. 修饰方法：静态方法
   - 静态方法属于类，而非类的实例
   - 特点
     - 可以在不创建类的实例的情况下调用
     - 不能访问类的实例变量或实例方法，他们只能访问其他的静态成员
     - 常用于工具类的方法
3. 静态代码块
   - 用于初始化类的静态变量
   - 特点：
     - 当类被 JVM 加载并初始化时执行
     - 通常用于执行静态变量的复杂初始化
4. 静态内部类：
   - 在一个类的内部定义的静态类
   - 特点：
     - 可以不依赖于外部类的实例而独立存在
     - 可以访问外部类的所有的静态成员，但是不能访问外部类的实例成员
     - 常用于当内部类的行为不应该依赖于外部类的实例时。

## 18. Object

#### 1. 方法

- equals 方法：判断两个对象是否相等
- hashCode 方法：生成对象的哈希码，返回的是一个整数，用于确定对象在哈希表中的位置。（有 hash 碰撞的问题）
  - 如果两个对象通过 equals 比较时相等的，那么这两个对象的 hashCode 方法返回相同的整数值。
- toString 方法：返回类的名字实例的哈希码的16 机制字符串
- notify 方法：唤醒一个在此对象监视器上等待的线程（多个线程等待只会唤醒一个）
- notifyAll 方法： 唤醒词对象监视器上等待的全部线程
- wait(long timeout) 方法：暂停线程的执行，释放了锁
- finalize 方法：实例被垃圾回收器回收的时候触发的操作



#### 2. 重写 equals 时必须重写 hashCode 方法

如果 equals 判断两个对象相等，那么使用 hashCode 值也要相等，不过不重写 hashCode 方法，那么可能会导致 equals 判断相等的对象 hashCode 值不相等，



## 19. 其他

#### 2. final、finally、finalize 有什么区别？

- final：用来声明变量、方法或类，是指不可变、不可重写、不可继承；
  - final 修饰的变量为常量，一旦复制之后，不能被修改
  - final 修饰类：不能被继承
  - final 修饰方法：不能被重写
- finally：是异常处理的一部分，确保代码块（通常用于资源清理）总是执行。
- finalize：是Object 的一个方法，用于在对象被垃圾回收前执行清理操作，通常不推荐使用。



被 `final` 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象







# Java 集合

### 1. Java 集合框架

存放单一元素Collection：

- Set（不可重复）
  - HashSet（哈希表）
    - LinkedHashSet
  - SortedSet（接口）
    - TreeSet（有序，唯一）红黑树（自平衡的排序二叉树）
- List（有序、可重复的）
  - ArrayList（数组）
  - LinkedList（1.7之后不是循环链表了，单纯的链表）
  - Vector
    - Stack
- Queue（有序，可重复的，有先后顺序）
  - Deque（接口）
    - ArrayDeque
    - LinkedList
  - PriorityQueue：数组实现小顶堆
  - DelayQueue

存放键值对 Map：（key 是无序的，不可重复的，value是无需的，可重复的，每个键最多映射到一个值）

- HashMap（数组+链表）
  - LinkedHashMap（链表+哈希表）
- Hashtable（数组+链表）
- SortedMap
  - TreeMap（红黑树，自平衡的排序二叉树）

### 2. List

#### 1. ArrayList 和 Array 的区别

- 动态数组
- 可以扩容
- 使用泛型保证类型的安全
- 只能存储对象
- 支持插入、删除、遍历等操作
- 不需要指定大小



#### 2. ArrayList 和 Vector 的区别？

- 都是使用 Object [] 存储
- 线程安全
- 一个是主要实现类，一个是古早实现类



#### 3.ArrayList 和 LinkedList 的区别

- 都是线程不安全的
- 一个使用数组，一个双向链表
- 插入和删除元素效率不一样
- 支持快速访问
- 内存占用

#### 4. Vector 和 Stack 的区别

- 都是线程安全，使用 synchronized 关键字进行同步处理。
- Stack 继承 Vector，是一个后进先出的栈，Vector 是一个列表



### 3. Set

#### 1. Comparable 和 Comparator 的区别



#### 2.HashSet、LinkedHashSet 和 TreeSet 的区别

- 实现了 Set 接口，线程不安全，元素唯一
- 底层数据结构不同



### 4.Queue

#### 1.Queue 和 Deque 的区别

- Queue：单端队列

  - | Queue 接口   | 抛出异常 | 返回特殊值 |
    | ------------ | -------- | ---------- |
    | 插入队列     | add      | offer      |
    | 删除队首     | remove   | poll       |
    | 查询队首元素 | element  | peek       |

- Deque：双端队列

  - | Deque 接口   | 抛出异常    | 返回特殊值 |
    | ------------ | ----------- | ---------- |
    | 插入队首     | addFirst()  | offerFirst |
    | 插入队尾     | addLast()   | offerLast  |
    | 删除队首     | removeFirst | pollFirst  |
    | 删除队尾     | removeLast  | pollLast   |
    | 查询队首元素 | getFirst    | peekFirst  |
    | 查询队尾     | getLast     | peekLast   |



### 5. Map

#### 1. HashMap 和 Hashtable 的区别

- 线程不安全
- 效率较高
- 支持 nullkey 和 nullValue
- 初始容量大小和扩容大小不一样
  - HashMap：16 - 2 （给定容量会扩充为 2 的幂次方大小）
  - Hashtable：11 - 2n+1



#### 2. HashMap 和 HashSet 的区别

- HashSet 底层基于 HashMap 实现的

















# JVM 篇

#### 1.常见的垃圾回收器

1. 串行垃圾回收器（Serial Garbage Collector）：Serial GC、Serial Old；
2. 并行垃圾回收器（Parallel Garbage Collector）：Parallel Scavenge、Parallel Old、ParNew
3. 并发标记扫描垃圾回收器（CMS Garbage Collector）（Concurrent Mark Sweep）
4. G1 垃圾回收器（JDK 7 推出，JDK9 默认）
5. ZGC 垃圾回收器（The Z Garbage Collector，JDK 11 推出）

新生代：Serial（单线程、标记-复制）、Parallel Scavenge（标记-复制）、ParNew（多线程、标记-复制）

老年代：Serial Old（标记-整理）、Parallel Old（标记-整理）、CMS（标记-清除）

整堆：G1、ZGC



串行垃圾回收器，单线程，可以较少上下文切换，减少系统开销，但是在GC 的时候，必须暂停其他的工作线程，直到回收器收集结束为止（Stop The World）



#### 2. 垃圾回收算法

- 标记-清除：直接清空垃圾内存
  - 优点：速度快、不需要移动和复制对象
  - 缺点：内存空间不连续，有内存碎片，造成内存的浪费
- 标记-复制：两块内存，一块快满的时候，复制到另一块内存中，严格排序且连续，腾出来的一块直接全部清除。依次循环运行。
  - 优点：内存地址是连续的，不会产生内存碎片
  - 缺点：浪费了一般的内存空间，复制对象会造成性能和时间上的消耗
- 标记-整理：标记存活对象和垃圾对象（标记），移动存活对象，按照地址次序依次排列，将末端内存地址之后内存全部回收（整理）
  - 优点：不会产生内存碎片，不会浪费内存空间
  - 去点：太耗性能（时间）

从时间长短来看：清除 < 复制 < 整理

从结果来看：整理 > 复制 >= 清除



#### 2. JIT技术

当 JVM 发现某个方法或代码块运行时执行特别频繁的时候，就会认为这是“热点代码”，把这一部分代码翻译成本地机器相关的机器码，进行优化，并缓存下来，以备下次使用。







# 计算机网络

#### 1. OSI 七层模型

应用层：为计算机用户提供服务

表示层：数据处理（编解码、加密解密、压缩解压缩、序列化、反序列化）

会话层：管理（建立、维护、重连）应用程序之间的会话

传输层：为两台主机进程之间的通信提供通用的数据传输服务

网络层：路由和寻址：确定数据在网络中的游走路径

数据链路层：帧编码和误差纠正控制

物理层：透明地传送比特流传输



##### TCP/IP 四层模型：

1. 应用层
2. 传输层
3. 网络层
4. 网络接口层









































































































































































































































































































































































