---
title: MySQL
date: 2024-08-17
updated: 2024-08-19
category: MySQL
cover: https://tse3-mm.cn.bing.net/th/id/OIP-C.LvJiXW0ldtBwCwC5TBSh4QHaEK?w=321&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---

# MySQL

## 1.数据库的基本概念

数据(Data)：所有能输入计算机中，并被计算机程序处理的符号总称叫做数据。数据可以是符号，也可以是文字、数字、语音、图像、视频等等。

数据库(Database)：简称DB，数据库是**按照一定的结构来组织、存储和管理数据的仓库**。

数据库管理系统(Database Management System)：简称 DBMS，数据库管理系统是一种**操纵和管理数据库的大型软件**，用于创建、使用和维护数据库。



## 2. 数据库分类

数据库分为关系数据库和非关系数据库两类：

**关系型数据库**(Relational Database Management System)：是建立在**关系模型**的基础上，由若干个相互关联的**二维表**组成的数据库。

关系型数据库特点：

1、使用二维表来存储数据，格式统一，便于维护。

2、使用SQL语句操作数据库，标准统一，使用方便。

3、数据存储在磁盘中，相对安全。

**非关系型数据库**：NoSQL（Not Only SQL），是对关系型数据库的补充。这类数据库与传统的关系型数据库在设计和结构上有很大的不同，它们更强调数据库数据的高并发读写和存储大数据。目前几种主流的非关系型数据库包括：键值(Key-Value)存储数据库(如Redis)、列存储数据库(如HBase)、文档型数据库(如MongoDB)等。

非关系型数据库特点：

1、易扩展。

2、大数据量、高性能。

3、灵活的数据模型。



## 3. 关系型数据库介绍

关系型数据库是应用最广泛的一种数据库。以表、行和列的结构来组织和处理数据。

**表：**是一个命名的**存储空间**，也称实体，用来保存数据。

**列：**是表中一组命名的**属性**，也称字段。每个列都有自己的数据类型，比如数值型、字符型、日期型等。列用来定义表的结构。

**行：**是表中的一条数据，也称记录。



## SQL 分类

SQL语言可分为如下5种，本课程需重点掌握DML、DQL、TCL语言，理解DDL语言、了解DCL即可

| **分类**                           | **名称**     | **用途**                           | **代表关键字**                                   |
| ---------------------------------- | ------------ | ---------------------------------- | ------------------------------------------------ |
| DDL (Data Definition Language)     | 数据定义语言 | 用来定义数据库、表及其它对象的结构 | CREATE、DROP、ALTER                              |
| DML (Data Manipulation Language)   | 数据操作语言 | 用来增加、修改、删除表中的数据     | INSERT、DELETE、UPDATE                           |
| DQL (Data Query Language)          | 数据查询语言 | 用来查询表中的数据                 | SELECT、FROM、WHERE、ORDER BY 、GROUP BY、HAVING |
| DCL (Data Control Language)        | 数据控制语言 | 用来授予和收回权限                 | GRANT、REVOKE                                    |
| TCL (Transaction Control Language) | 事务处理语言 | 用来对数据进行提交和回滚           | COMMIT、ROLLBACK                                 |



> 注意：
>
> - 空值参与算术运算后，结果仍为空值
> - 用ifnull(field,0)来解决空值的问题，如果 field 不为空，就返回原值 ，如果为空则返回默认值 0

起别名：as 或 空格

消除重复行：distinct 后面跟多个 field 时，是联合查询消除重复 field



like 匹配：

- %  : 百分号，代表匹配零个或任意个字符。
- _   : 下划线，代表匹配1个任意字符。



区分大小写：  BINARY

查询空值不能使用 =null 而是使用 IS NULL

逻辑运算符包含逻辑与 AND，逻辑或 OR，逻辑非 NOT 【 NOT (job='CLERK')  \  !=  \  <> 】都代表NOT。



> **NOT运算符还可以和BETWEEN…AND、IN、LIKE、IS NULL一起使用，表示的含义分别为：**
>
> NOT BETWEEN .. AND .. :不在某个区间
>
> NOT IN (集合）：不在某个集合内
>
> NOT LIKE    ：不像.....
>
> IS NOT NULL:  不是空



排序: order by 

> - ASC表示按升序排序(默认值), DESC表示按降序排序。
> - ORDER BY 子句必须写在SELECT语句的最后
> - 可以同时按照多个列名进行排序  ORDER BY  deptno ASC, sal DESC;





连接的本质就是过滤掉或者避免产生无意义的两个表的组合数据。

> N 张表进行连接至少需要 N-1 个连接条件

多表连接分类：

- 按连接条件分：

  - 等值连接：等值连接就是对连接条件进行有效的等值判断。

  - 非等值连接

- 按其他连接方法分：

  - 外连接

  - 内连接



笛卡尔积，在数据库中表示将A表中每条记录与B表中的每条记录进行连接，连接后的查询结果就是笛卡尔积，也叫交叉连接。

> 在实际应用中，笛卡尔积本身大多没有什么实际用处，而且还有一个附加问题：产生一个巨表。
>
> - 笛卡尔积在下列情况产生：
>
> - 连接条件被省略
> - 连接条件是无效的
>
> - 为了避免笛卡尔积的产生，通常需要在 WHERE 子句中包含一个有效的连接条件



自连接：是一个表通过某种条件和本身进行连接的一种方式，就如同多个表连接一样。



外连接：

> - 在多表连接时，可以使用外部连接来查看没有匹配连接条件的数据行。
>
> - 左外连接以 LEFT OUTER JOIN 关键字左边的表为基表，该表所有行数据按照连接条件无论是否与右边表能匹配上，都会被显示出来。(右边匹配不上为 null)
> - 右外连接以RIGHT OUTER JOIN子句中的右边表为基表，该表所有行数据按照连接条件无论是否与左边表能匹配上，都会被显示出来。（左边匹配不上为 null）



分组查询

| **分组函数** | **含义** |
| ------------ | -------- |
| MAX          | 求最大值 |
| MIN          | 求最小值 |
| SUM          | 求和     |
| AVG          | 求平均值 |
| COUNT        | 求个数   |



```sql
SELECT    列名, 分组函数
FROM      表名
WHERE    条件表达式
ORDER BY 列名;
```



```sql
MIN( [ DISTINCT | ALL ] 列名 | 表达式 )
MAX( [ DISTINCT | ALL ] 列名 | 表达式 )
```



```sql
SUM( [ DISTINCT | ALL ] 列名 | 表达式 )
AVG( [ DISTINCT | ALL ] 列名 | 表达式 )
```



COUNT函数用来返回满足条件的每组记录个数，语法如下：

1. COUNT(*)：返回满足条件的每组记录个数。
2. COUNT( [ DISTINCT | ALL ] 列名 | 表达式 )：返回满足条件的每组**非空**记录个数。

说明：

**5个分组函数，除COUNT(\*)不忽略掉空值外，其余函数都是忽略掉空值再进行运算。**





SELECT 子句、FROM 子句、WHERE 子句、GROUP BY 子句、 HAVING 子句、ORDER BY 子句，书写直接按照此顺序就可以。那么这一条完整的 SELECT 子句发送到数据库服务器，执行顺序是如何的，可以通过案例来了解一下。

如下SQL语句：

```sql
SELECT    deptno,job,avg(sal) 
FROM      emp 
WHERE      job in ('SALESMAN','MANAGER','CLERK') 
GROUP BY  deptno,job 
HAVING avg(sal)>1000 
ORDER BY  3 DESC; 
```

**执行过程：**

1、通过 FROM 子句中找到需要查询的表；

2、通过 WHERE 子句进行非分组函数筛选判断；

3、通过 GROUP BY 子句完成分组操作；

4、通过HAVING子句完成组函数筛选判断；

5、通过SELECT子句选择显示的列或表达式及组函数；

6、通过ORDER BY子句进行排序操作。





分页查询：

```sql
SELECT 字段列表
FROM 数据源
LIMIT [start,]length;
```





## DDL（数据定义语言）

> 用来定义数据对象（数据库、表、字段）

### 数据库操作

```sql
show databases;
select database();
create database [ if not exists]  数据库名 [ default charset 字符集(utf8mb4) ] [collate 排序规则 ];
delete database [if exists] 数据库名;
use 数据库名;
```

### 表操作

```sql
select tables;
desc 表名;
show create table 表名; # 查询指定表的建表语句
```

#### 创建表的结构

```sql
CREATE TABLE 表名(
    字段1 字段1类型 [ COMMENT 字段1注释 ],
    字段2 字段2类型 [COMMENT 字段2注释 ],
    字段3 字段3类型 [COMMENT 字段3注释 ],
    ......
    字段n 字段n类型 [COMMENT 字段n注释 ]
) [ COMMENT 表注释 ] ;
```



#### 数据类型

- 数值类型：TINYINT、SMALLINT、MEDIUMINT、INT/INTRGRT、BIGINT、FLOAT、DOUBLE、DECIMAL
  - TINYINT UNSIGNED（不会出现负数）
  - DOUBLE(4,1):100.0
- 字符串类型：CHAR(1)、VARCHAR(90)、TINYBLOB、BLOB、TEXT、MEDIUMBLOB、MEDIUMTEXT、BIGBLOB、BIGTEXT;
  - CHAR：定长字符串，需要指定长度，最大255
  - VARCHAR：变长字符串，需要指定长度，最大65535
- 时间类型：DATE、TIME、YEAR、DATETIMR、TIMESTAMP



#### 修改表的结构

```sql
ALTER TABLE 表名 ADD 字段名 类型（长度） [ COMMENT 注释 ][ 约束 ];
ALTER TABLE　MODIFY 字段名 新数据类型（长度）;
ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [ COMMENT 注释 ] [约束];
ALTER TABLE 表名 DROP 字段名;
ALTER TABLE 表名 RENAME TO 新表名;
```



```sql
DROP TABLE [IF EXISTS] 表名;
TRUNCATE TABLE 表名; # 删除并重建表
```



## DML 数据操作语言

> 对数据库中表的数据进行增、删、改操作
>
> - INSERT
> - UPDATE
> - DELETE



### 增

```sql
INSERT INTO 表名 (字段名1，字段名2，……) VALUES (值1，值2，……);
INSERT INTO 表名 VALUES (值1，值2，……); # 给全部字段添加数据
INSERT INTO 表名 VALUES (值1，值2，……),(值1，值2，……);
```



### 改

```sql
UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2,…… [WHERE 条件]; 
```

> 注意事项：
>
> - 修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表的所有数据。



### 删

```SQL
DELETE FROM 表名 [WHERE 条件];
```

> 注意事项：
>
> - DELETE 语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据。
> - DELETE 语句不能删除某一个字段的值(可以使用UPDATE，将该字段值置为NULL即可)。



## DQL 数据查询语言

> 用来查询数据库中表的记录
>
> - SELECT

编写顺序

```SQL
SELECT
	字段列表
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后条件列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
```

执行顺序

```SQL
FROM
	表名列表
WHERE
	条件列表
GROUP BY
	分组字段列表
HAVING
	分组后条件列表
SELECT
	字段列表
ORDER BY
	排序字段列表
LIMIT
	分页参数
```

> DQL语句的执行顺序为： from ... where ... group by ... having ... select ... order by ... limit ...

查询语句：

```SQL
SELECT 字段1，字段2，字段2，…… FROM 表名 WHERE 条件列表;
SELECT 字段1 [AS 别名1]，…… FROM 表名; # AS 可以省略
SELECT DISTINCT 字段列表 FROM 表名;
SELECT * FROM 表名; 
```

> 注意：
>
> *  **\*** 号代表查询所有字段，在实际开发中尽量少用（不直观、影响效率）。



### 条件

#### 比较运算符

| 比较运算符      | 功能                                       |
| --------------- | ------------------------------------------ |
| >               |                                            |
| >=              |                                            |
| <               |                                            |
| <=              |                                            |
| =               |                                            |
| <> / !=         |                                            |
| BETWEEN … AND … | 包含最大、最小                             |
| IN(…)           |                                            |
| LIKE 占位符     | 模糊匹配（_匹配单个字符、%匹配人一个字符） |
| IS NULL         |                                            |

#### 逻辑运算符

| 逻辑运算符 | 功能 |
| ---------- | ---- |
| AND / &&   |      |
| OR / \|\|  |      |
| NOT /!     |      |



### 聚合函数

> 将一列数据作为一个整体，进行纵向计算

| 函数  | 功能     |
| ----- | -------- |
| COUNT | 统计数量 |
| MAX   | 最大值   |
| MIN   | 最小值   |
| AVG   | 平均值   |
| SUM   | 求和     |

> 注意：
>
> - NULL 值是不参与所有的聚合函数运算的。

```SQL
SELECT 聚合函数(字段列表) FROM  表名;
```



### 分组查询

```SQL
SELECT 字段列表 FROM 表名 [WHERE 条件] GROUP BY 分组字段名 [HAVING 分组后过滤条件];
```

>  where与having区别
>
> - 执行时机不同：where是分组之前进行过滤，不满足where条件，不参与分组；而having是分组之后对结果进行过滤。
>
> - 判断条件不同：where不能对聚合函数进行判断，而having可以。

> 注意事项:
>
> -  分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义。
> - 执行顺序: where > 聚合函数 > having 。
>
> - 支持多字段分组, 具体语法为 : group by columnA,columnB



### 排序

```SQL
SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1， 字段2 排序方式2；
```

排序方式：

- ASC : 升序(默认值)

+ DESC: 降序

> 注意事项：
>
> - 如果是升序, 可以不指定排序方式ASC ;
> - 如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序 ;



### 分页查询

```SQL
SELECT 字段列表 FROM 表名 LIMIT 起始索引，查询记录数;
```

> 注意事项： 
>
> - 起始索引从0开始，起始索引 = （查询页码 - 1）* 每页显示记录数。
> - 分页查询是数据库的方言，不同的数据库有不同的实现，MySQL中是LIMIT。
> - 如果查询的是第一页数据，起始索引可以省略，直接简写为 limit 10。



## DCL 数据控制语言

> 用来管理数据库用户、控制数据库的访问权限

```SQL
SELECT * FROM MYSQL.USER; # 查询用户
CREATE USER '用户名'@'主机名' IDENTIFIED BY '密码';
ALTER USER '用户名'@'主机名' IDENTIFIED WITH mysql_native_password BY '新密码' ;
DROP USER '用户名'@'主机名' ;
```

> 注意事项:
>
> - 在MySQL中需要通过用户名@主机名的方式，来唯一标识一个用户。
> - 主机名可以使用 % 通配。
> - 这类SQL开发人员操作的比较少，主要是DBA（ Database Administrator 数据库管理员）使用。

权限分类

| 权限              | 说明               |
| ----------------- | ------------------ |
| ALL,ALL PRIVLEGES | 所有权限           |
| SELECT            | 查询数据           |
| INSERT            | 插入数据           |
| UPDATE            | 修改数据           |
| DELETE            | 删除数据           |
| ALTER             | 修改表             |
| DROP              | 删除数据库/视图/表 |
| CREATE            | 创建数据库/表      |



 ```SQL
 SHOW GRANRS FOR '用户名'@'主机名';
 GRANT 权限列表 ON  数据库名.表名 TO '用户名'@'主机名';
 REVOKE 权限列表 ON 数据库名.表名 TO '用户名'@'主机名';
 ```

> 注意事项：
>
> - 多个权限之间，使用逗号分隔
> - 授权时， 数据库名和表名可以使用 * 进行通配，代表所有。



## 函数

### 字符串函数

| 函数                     | 功能                                                    |
| ------------------------ | ------------------------------------------------------- |
| CONCAT(S1,S2,…,Sn)       | 字符串拼接                                              |
| LOWER(str)               | 将字符串 str 全部转为小写                               |
| UPPER(str)               | 转大写                                                  |
| LPAD(STR,N,PAD)          | 左填充，用字符串pad对str的左边进行填充，达到n个字符长度 |
| RPAD(str,n,pad)          | 右填充，用字符串pad对str的右边进行填充，达到n个字符长度 |
| TRIM(str)                | 去掉字符串头部和尾部的空格                              |
| SUBSTRING(str,start,len) | 返回从字符串str从start位置起的len个长度的字符串         |



### 数值函数

| 函数       | 功能                                   |
| ---------- | -------------------------------------- |
| CEIL(X)    | 向上取整                               |
| FLOOR(X)   | 向下取整                               |
| MOD(X,Y)   | 返回 x/y 的模                          |
| RAND()     | 返回 0~1 内的随机数                    |
| ROUND(X,Y) | 求参数 x 的四舍五入的值，保留 y 位小数 |



### 日期函数

| 函数                           | 功能                                                |
| ------------------------------ | --------------------------------------------------- |
| CURDATE()                      | 返回当前日期                                        |
| CURTIME()                      | 返回当前时间                                        |
| NOW()                          | 返回当前的日期和时间                                |
| YEAR(date)                     | 获取指定 date 的年份                                |
| MINTH(date)                    |                                                     |
| DAY(date)                      |                                                     |
| DATE_ADD(date, INTER,exprtype) | 返回一个日期/时间值加上一个时间间隔 expr 后的时间值 |
| DATEDIFF(date1,date2)          | 返回其实时间 date1 和 结束时间 date2 之间的天数     |



### 流程函数

| 函数                                                         | 功能                                                       |
| ------------------------------------------------------------ | ---------------------------------------------------------- |
| IF(value , t , f)                                            | 如果value为true，则返回t，否则返回f                        |
| IFNULL(value1 , value2)                                      | 如果value1不为空，返回value1，否则返回value2               |
| CASE WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END      | 如果val1为true，返回res1，... 否                           |
| CASE [ expr ] WHEN [ val1 ] THEN [res1] ... ELSE [ default ] END | 如果expr的值等于val1，返回 res1，... 否则返回default默认值 |



## 约束

> 概念：约束是作用于表中字段上的规则，用于限制存储在表中的数据。
>
> 目的：保证数据库中数据的正确、有效性和完整性。

分类：

| 约束                       | 描述                                                     | 关键字      |
| -------------------------- | -------------------------------------------------------- | ----------- |
| 非空约束                   | 限制该字段的数据不能为null                               | NOT NULL    |
| 唯一约束                   | 保证该字段的所有数据都是唯一、不重复的                   | UNIQUE      |
| 主键约束                   | 主键是一行数据的唯一标识，要求非空且唯一                 | PRIMARY KEY |
| 默认约束                   | 保存数据时，如果未指定该字段的值，则采用默认值           | DEFAULT     |
| 检查约束（8.0.16版本之后） | 保证字段值满足某一个条件                                 | CHECK       |
| 外键约束                   | 用来让两张表的数据之间建立连接，保证数据的一致性和完整性 | FOREIGN KEY |

> 注意：
>
> - 约束是作用于表中字段上的，可以在创建表/修改表的时候添加约束。
> - 在为字段添加约束时，只需要在字段之后加上约束的关键字即可



增加外键

```SQL
[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)

ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名) ;
```



删除外键

```SQL
ALTER TABLE 表名 DROP FOREIGN KEY 外键名称;
```





## 多表查询

- 一对一：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(UNIQUE)
- 一对多：在多的一方建立外键，指向另一方的主键。
- 多对多：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键

> 会出现的问题：
>
> 笛卡尔积：笛卡尔乘积是指在数学中，两个集合 A 集合 和 B 集合的所有组合情况。在多表查询中，需要消除无效的笛卡尔积的，只保留两张表关联部分的数据。（给多表查询加上连接查询的条件即可消除笛卡尔积）

连接查询

- 内连接：相当于查询两张表交集部分数据。分为： 隐式内连接、显式内连接。
  - 如果某一行在其中一个表中有匹配而在另一个表中没有，则该行不会出现在结果集中。

- 外连接：
  - 外连接不仅返回满足连接条件的记录，还会返回某个表中不匹配的记录，并用 NULL 填充另一侧表的字段。
- 左外连接：查询左表所有数据，以及两张表交集部分数据
- 右外连接：查询右表所有数据，以及两张表交集部分数据
- 自连接：当前表与自身的连接查询，自连接必须使用表别名

子查询



### 连接查询



#### 内连接

```SQL
SELECT 字段列表 FROM 表1，表2 WHERE 条件…;
# 显示内连接
SELECT 字段列表 FROM 表1 [INNER] JOIN 表2 ON  连接条件…；
```



#### 外连接

```SQL
# 左外连接
SELECT 字段列表 FROM 表1 LEFT [OUTER] JOIN 表2 ON 条件;
# 右外连接
SELECT 字段列表 FROM 表1 RIGHT [OUTER] JOIN 表2 ON 条件;
```

> 左外连接和右外连接是可以相互替换的，只需要调整在连接查询时 SQL 中表的先后顺序就可以了。而在日常开发使用时，更偏向于左外连接。



#### 自连接

顾名思义，就是自己连接自己，也就是把一张表连接查询多次

```SQL
SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ... ;
```

> 注意：
>
> - 在自连接查询中，必须要为表起别名，要不然我们不清楚所指定的条件、返回的字段，到底是哪一张表的字段。



#### 联合查询

对于 union 查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。

> 先查询出来，在合并成一个结果集

```SQL
SELECT 字段列表 FROM 表A ...
UNION [ ALL ]
SELECT 字段列表 FROM 表B ....;
```

- 对于联合查询的多张表的列数必须保持一致，字段类型也需要保持一致。
- **UNION**：合并两个或多个 SELECT 语句的结果，并且自动去除重复行。
- **UNION ALL**：合并两个或多个 SELECT 语句的结果，并且保留所有行，包括重复行。



### 子查询

> SQL语句中嵌套SELECT语句，称为嵌套查询，又称子查询。
>
> - 子查询外部的语句可以是 INSERT / UPDATE / DELETE / SELECT 的任何一个。

```SQL
SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2 );
```

根据子查询结果不同，分为：

A. 标量子查询（子查询结果为单个值）

B. 列子查询(子查询结果为一列)

| 操作符 | 描述                                        |
| ------ | ------------------------------------------- |
| IN     | 在指定的集合范围之内，多选一                |
| NOT IN | 不在指定集合范围之内                        |
| ANY    | 子查询返回列表中，有任意一个满足即可        |
| SOME   | 与 ANY 等同，使用 SOME 的地方都可以使用 ANY |
| ALL    | 子查询返回列表的所有值都必须满足            |

C. 行子查询(子查询结果为一行)

D. 表子查询(子查询结果为多行多列)



根据子查询位置，分为：

A. WHERE之后

B. FROM之后

C. SELECT之后





### 事务

**事务：**是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。

> 注意：
>
> - 默认MySQL的事务是自动提交的，也就是说，当执行完一条DML语句时，MySQL会立即隐式的提交事务。



```SQL
SELECT @@autocommit ; # 查看事务提交方式
SET @@autocommit = 0 ; # 设置事务提交方式
START TRANSACTION 或 BEGIN ; # 开启事务
COMMIT; # 提交事务
ROLLBACK; # 回归事务
```



### ACID：事务的四大特性

- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。（即便有多个事务同时进行，每个事务都应该与其他事务隔离开来。事务所做的修改在最终提交之前对于其它事务来说是不可见的。不同的事务级别可以提供不同程度的隔离，但基本原则是事务不应该相互干扰。）
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。



### 并发事务的问题

- 脏读：一个事务读到了另外一个事务还没有提交的数据
- 不可重复读：在一个事务中，先后读取同一条数据，但两次读取的数据不同，称为不可重复读。
- 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”。



### 事务的隔离级别

```SQL
SELECT @@TRANSACTION_ISOLATION; # 查看事务的隔离级别，早期版本不支持，早期版本支持如下
SELECT @@TX_ISOLATION; # 一些早期版本支持，8.0 版本也支持
SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED |READ COMMITTED | REPEATABLE READ | SERIALIZABLE}
```



| 隔离级别                | 脏读 | 不可重复读 | 幻读 |
| ----------------------- | ---- | ---------- | ---- |
| Read uncommitted        | √    | √          | √    |
| Read committed          | ×    | √          | √    |
| Repeatable Read（默认） | ×    | ×          | √    |
| Serializeable           | ×    | ×          | ×    |

> 注意：
>
> - 事务隔离级别越高，数据越安全，但是性能越低。



## 索引

索引（index）是帮助 MySQL 高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

```SQL
CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name,…);
# 查看表里面有哪些索引
SHOW IDNEX FROM TABLE_NAME;
DROP INDEX index_name ON table_name;
```



#### 特点

| 优势                                                         | 劣势                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提高数据检索的效率，降低数据库的 IO 成本                     | 索引列也是要占用空间的。                                     |
| 通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 INSERT、UPDATE、DELETE 时，效率降低。 |

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree索引          | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |
| Hash索引            | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询 |
| R-tree(空间索引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES |



#### 为啥不选二叉树作为索引？

选择二叉树作为索引结构，会存在以下缺点：

- 顺序插入时，会形成一个链表，查询性能大大降低。

- 大数据量情况下，层级较深，检索速度慢。



#### B-Tree

B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。

以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针。

特点：

- 5阶的 B 树，每一个节点最多存储4个 key，对应5个指针（每个关键字都夹在两个指针之间）。

- 一旦节点存储的 key 数量到达 5，就会裂变，中间元素向上分裂。

- 在 B 树中，非叶子节点和叶子节点都会存放数据。



#### B+Tree

B+Tree 是 B-Tree 的变种

B+Tree 的中间节点值存储索引，不存储数据，存储数据的是叶子节点。

> B+Tree 与 B-Tree 相比，主要有以下三点区别：
>
> - 所有的数据都会出现在叶子节点。
> - 叶子节点形成一个单向链表。
> - 非叶子节点仅仅起到**索引数据**作用，具体的数据都是在叶子节点存放的。



MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能，利于排序。

> 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？
>
> - 相对于二叉树，层级更少，搜索效率高；
> - 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
> - 相对Hash索引，B+tree支持范围匹配及排序操作；



### 索引分类

在 MySQL 数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建, 只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |



#### 聚集索引（聚簇索引） & 二级索引

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                        | 含义                                                         | 特点                 |
| --------------------------- | ------------------------------------------------------------ | -------------------- |
| 聚集索引（Clustered Index） | 将**数据存储与索引**放到一块，索引结构的叶子节点保存了行数据 | 必须有，且只能由一个 |
| 二级索引（Secondary Index） | 将数据与索引分开存储，**索引结构的叶子节点关联的是对应的主键**。因此查询了二级索引需要回表。 | 可以存在多个         |

![聚集索引 和 二级索引](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240821122338264.png)

聚集索引选取规则：

- 如果存在主键，主键索引就是聚集索引。
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
- 如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 row_id 作为隐藏的聚集索引。
  - 这就是如果创建表的时候没有主键，根据什么构造 B+树


> 先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。(根据二级索引查数据比 id 慢)





## SQL 性能分析

### SQL 执行效率

通过` show [session|global] status` 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的`INSERT、UPDATE、DELETE、SELECT` 的访问频次：

```SQL
 SHOW GLOBAL STATUS LIKE 'Com_______'; # (七个下杠，一个_+6个单词)
```

![sql 性能分析](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240819144421200.png)

> 通过上述指令，可以查看到当前数据库到底是以查询为主，还是以增删改为主，从而为数据库优化提供参考依据。 如果是以增删改为主，可以考虑不对其进行索引的优化。 如果是以查询为主，那么就要考虑对数据库的索引进行优化了。



### 慢查询日志

慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有 SQL 语句的日志。

MySQL 的慢查询日志默认没有开启，同一通过系统变量查看 `slow_query_log`。

```SQL
SHOW VARIABLES LIKE 'slow_query_log'; # 关闭显示 OFF，开启显示 ON
```

开启慢查询日志，需要在 MySQL 的`配置文件` （/etc/my.cnf）中配置如下：

```sql
# 开启MySQL慢日志查询开关
slow_query_log=1
# 设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志
long_query_time=2
```

配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息 `/var/lib/mysql/localhost-slow.log`。

```SHELL
systemctl restart mysqld
```



### profile 

`show profiles` 能够在做 SQL 优化时帮助我们了解时间都耗费到哪里去了。通过`have_profiling` 参数，能够看到当前 MySQL 是否支持 profile 操作。

MySQL是支持 profile操作的，但是开关是关闭的。可以通过set语句在 session/global级别开启profiling：

```SQL
SELECT @@have_profiling;
SET peofile = 1;
```



```SQL
-- 查看每一条SQL的耗时基本情况
show profiles;
-- 查看指定query_id的SQL语句各个阶段的耗时情况
show profile for query query_id;
-- 查看指定query_id的SQL语句CPU的使用情况
show profile cpu for query query_id;
```



### explain

EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。

```SQL
EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;
```

![explain 的使用](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240819152504591.png)

| 字段         | 含义                                                         |
| ------------ | ------------------------------------------------------------ |
| id           | select查询的序列号，表示查询中执行select子句或者是操作表的顺序(id相同，执行顺序从上到下；id不同，值越大，越先执行)。 |
| select_type  | 表示 SELECT 的类型，常见的取值有 SIMPLE（简单表，即不使用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION 中的第二个或者后面的查询语句）、SUBQUERY（SELECT/WHERE之后包含了子查询）等 |
| type         | 表示连接类型，性能由好到差的连接类型为NULL、system、const、eq_ref、ref、range、 index、all 。 |
| possible_key | 显示可能应用在这张表上的索引，一个或多个。                   |
| key          | 实际使用的索引，如果为NULL，则没有使用索引。                 |
| key_len      | 表示索引中使用的字节数， 该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下， 长度越短越好 。 |
| rows         | MySQL认为必须要执行查询的行数，在 innodb 引擎的表中，是一个估计值，可能并不总是准确的。 |
| filtered     | 表示返回结果的行数占需读取行数的百分比， filtered 的值越大越好。 |



### 最左匹配原则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

通过创建索引

```SQL
CREATE INDEX INDEX_EMP ON EMP(ename,job,deptno);
```

之后通过 explain 分析可以看出：

![explain 查询](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240819154541676.png)

> 注意：
>
> -  最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。
>
> ![最左匹配](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240819154835875.png)



### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效（不包含使用 范围查询的列【索引仍然生效】）。

当范围查询使用>= 或 <= 时，走联合索引。

> 在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <



### 索引失效的情况

- 在索引上进行运算操作

- 字符串不加引号

- 头部模糊查询（尾部模糊查询 不会失效）

- or 连接条件有一方没有索引（两侧都是索引才会生效）

- 数据分布影响（索引比全表扫描慢的话，不走索引）

  > MySQL 在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。



### SQL 提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。

> 在查询数据时指定使用哪个索引？

```SQL
# use 建议 MySQL 使用哪一个索引（MySQL内部还会再次进行评估）
SELECT * FROM EMP USE INDEX(INDEX_EMP) WHERE ENAME = 'SMITH';
# 忽略指定索引 ignore
SELECT * FROM EMP IGNORE INDEX(INDEX_EMP) WHERE ENAME = 'SMITH';
# 强制使用索引 forcw
SELECT * FROM EMP FORCE INDEX(INDEX_EMP) WHERE ENAME = 'SMITH';
```



### 单列索引与联合索引

单列索引：即一个索引只包含单个列。

联合索引：即一个索引包含了多个列。

```SQL
CREATE INDEX index_name ON table_name(field1);
CREATE INDEX index_name ON table_name(field1, field2);
```

> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。



### 覆盖索引

**覆盖索引：**指查询使用了索引，并且需要返回的列，在该索引（联合索引）中已经全部能够找到 。

尽量使用覆盖索引，减少select *。 



| Extra                    | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Using where; Using index | 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 |
| Using index condition    | 查找使用了索引，但是需要回表查询数据                         |



### 前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

```SQL
CREATE INDEX INDEX_XXXX ON table_name(column(n)); 
```



#### 扫描时候创建索引

1). 针对于数据量较大，且查询比较频繁的表建立索引。

2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。

3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。

5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。

6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。

7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。





## SQL 优化

### 插入数据

一次性往数据库表中插入多条数据，可以通过以下三个方面来优化：

- 批量插入
- 手动控制事务
- 主键顺序插入（性能要高于乱序插入）

如果一次性需要插入大批量数据(比如: 几百万的记录)，使用`insert`语句插入性能较低，此时可以使用MySQL数据库提供的load指令进行插入。



```sql
-- 客户端连接服务端时，加上参数 -–local-infile
mysql –-local-infile -u root -p
-- 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关
set global local_infile = 1;
-- 执行load指令将准备好的数据，加载到表结构中
load data local infile '/root/sql1.sql' into table table_name fields terminated by ',' lines terminated by '\n' ;
```



#### 主键优化

主键不按顺序插入可能会出现 `页分裂` 现象，比较耗费性能。

**页合并：**当页中删除的记录达到 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。

> MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或者创建索引时指定。



索引设计原则：

- 满足业务需求的情况下，尽量降低主键的长度。
- 插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。
- 尽量不要使用 UUID 做主键或者是其他自然主键，如身份证号。
- 业务操作时，避免对主键的修改。



### Order 优化

MySQL的排序，有两种方式：

Using filesort : 通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序。

Using index : 通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高。

对于以上的两种排序方式，Using index的性能高，而Using filesort的性能低，我们在优化排序操作时，尽量要优化为 Using index。



#### Backward index scan

在MySQL中创建的索引，默认索引的叶子节点是从小到大排序的，而此时我们查询排序时，是从大到小，所以，在扫描时，就是反向扫描，就会出现 Backward index scan。

> 解决方案：创建联合索引同时设置排序方式

```SQL
create index idx_emp_age_sal on emp(age asc, sal desc);
```

order by优化原则:

- 根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。
- 尽量使用覆盖索引。
- 多字段排序, 一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC/DESC）。
- 如果不可避免的出现 filesort，大数据量排序时，可以适当增大排序缓冲区大小sort_buffer_size(默认256k)。



### groub by 优化

> group by 优化点：
>
> -  在分组操作时，可以通过索引来提高效率。
> - 分组操作时，索引的使用也是满足最左前缀法则的



### limit 优化

在数据量比较大时，如果进行limit分页查询，在查询时，越往后，分页查询效率越低。

优化思路：一般分页查询时，通过创建 **覆盖索引** 能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。

```SQL
# 这里走了 覆盖索引 id 可以提高性能。
select * from tb_sku t , (select id from tb_sku order by id
limit 2000000,10) a where t.id = a.id;
```



### count 优化

如果数据量很大，在执行count操作时，是非常耗时的。

- MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高； 但是如果是带条件的count，MyISAM也慢。
- InnoDB 引擎就麻烦了，它执行 count(*) 的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数。

要大幅度提升 InnoDB 表的 count 效率，主要的优化思路：自己计数(可以借助于 redis 这样的数据库进行,但是如果是带条件的 count 又比较麻烦了)。

count() 是一个聚合函数，对于返回的结果集，一行行地判断，如果 count 函数的参数不是 NULL，累计值就加 1，否则不加，最后返回累计值。

用法：count（*）、count（主键）、count（字段）、count（数字）

> 按照效率排序的话，count(字段) < count(主键 id) < count(1) ≈ count(\*)，所以尽量使用 count(\*)。

| count 用法    | 含义                                                         |
| ------------- | ------------------------------------------------------------ |
| count（主键） | InnoDB 引擎会遍历整张表，把每一行的 主键id 值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null) |
| count（字段） | 没有not null 约束 : InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加。<br />有not null 约束：InnoDB 引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。 |
| count（数字） | InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。 |
| count（*）    | InnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。 |



### update 优化

```sql
delete from user where id = 1;
```

在执行删除的SQL语句时，会锁定 id 为 1 这一行的数据，然后事务提交之后，行锁释放。

```mysql
update user set name = "zhan" where id = 1; 
```

当开启多个事务，在执行如下的SQL时，发现行锁升级为了表锁(因为没有走索引，走的是全表扫描)。 导致该update语句的性能大大降低。
```mysql
update user set name = "zhan" where name = "mahua"; 
```

> InnoDB的行锁是针对索引加的锁，不是针对记录加的锁 ,并且该索引不能失效，否则会从行锁升级为表锁 。





## 视图

**视图：**是一种虚拟存在的表。视图中的数据并不在数据库中实际存在，行和列数据来自定义视图的查询中使用的表，并且是在使用视图时动态生成的。

> 通俗的讲，视图只保存了查询的SQL逻辑，不保存查询结果。

```SQL
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [CASCADED | LOCAL ] CHECK OPTION ]

SHOW CREATE VIEW 视图名称; # 查看创建视图语句
SELECT * FROM 视图名称 ...... ; # 查看视图数据

```

修改视图：

```SQL
CREATE [OR REPLACE] VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED | LOCAL ] CHECK OPTION ];

ALTER VIEW 视图名称[(列名列表)] AS SELECT语句 [ WITH [ CASCADED |
LOCAL ] CHECK OPTION ];
```



删除视图

```SQL
DROP VIEW [IF EXISTS] 视图名称 [,视图名称] ...
```



> 对视图的操作会影响原表
>
> 如果定义视图时，如果指定了条件，然后在插入、修改、删除数据时，是否可以做到必须满足条件才能操作，否则不能够操作呢？ 答案是可以的，这就需要借助于视图的检查选项了。



### 检查选项

当使用`WITH CHECK OPTION`子句创建视图时，MySQL 会通过视图检查正在更改的每个行，例如 插入，更新，删除，以使其符合视图的定义。 MySQL 允许基于另一个视图创建视图，它还会检查依赖视图中的规则以保持一致性。为了确定检查的范围，MySQL 提供了两个选项： CASCADED 和 LOCAL，默认值为 CASCADED 。

#### CASCADED

级联。

比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 cascaded，但是 v1 视图创建时未指定检查选项。 则在执行检查时，不仅会检查 v2，还**会级联检查 v2 的关联视图 v1**。

```SQL
create view v1 as select id,name from user where id <= 20;
create view v2 as select * from v1 where if >= 10 with cascaded check option;
```



####  LOCAL

本地。

比如，v2 视图是基于 v1 视图的，如果在 v2 视图创建的时候指定了检查选项为 local ，但是 v1 视图创建时未指定检查选项。 则在执行检查时，只会检查 v2，**不会检查 v2 的关联视图 v1**。

```SQL
create view v1 as select id,name from user where id <= 20;
create view v2 as select * from v1 where if >= 10 with local check option;
```



### 视图的更新

要使视图可更新，视图中的行与基础表中的行之间必须存在一对一的关系。如果视图包含以下任何一项，则该视图不可更新：

- 聚合函数或窗口函数（SUM()、 MIN()、 MAX()、 COUNT()等）
- DISTINCT
- GROUP BY
- HAVING
- UNION 或者 UNION ALL



### 视图的作用

> - 简单：视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。
>
> - 安全：数据库可以授权，但不能授权到数据库特定行和特定的列上。通过视图用户只能查询和修改他们所能见到的数据
>
> - 数据独立：视图可帮助用户屏蔽真实表结构变化带来的影响。





## 存储过程（待补充）

**存储过程**是**事先经过编译并存储**在数据库中的**一段 SQL 语句的集合**，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。

存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。

> 特点：
>
> - 封装，复用 ------> 可以把某一业务SQL封装在存储过程中，需要用到的时候直接调用即可。
> - 可以接收参数，也可以返回数据 --------> 在存储过程中，可以传递参数，也可以接收返回值。
> - 减少网络交互，效率提升 --------> 如果涉及到多条SQL，每执行一次都是一次网络传输。 而如果封装在存储过程中，我们只需要网络交互一次可能就可以了。



### 基本语法

#### 创建

```SQL
CREATE PROCEDURE 存储过程名称 ([ 参数列表 ])
BEGIN
	-- SQL语句
END ;
```



#### 调用

```SQL
CALL 名称 ([ 参数 ]);
```



#### 查看

```SQL
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'xxx'; -- 查询指定数据库的存储过程及状态信息
SHOW CREATE PROCEDURE 存储过程名称 ; -- 查询某个存储过程的定义
```



#### 删除

```SQL
DROP PROCEDURE [ IF EXISTS ] 存储过程名称 ；
```



> 注意:
>
> - 在命令行中，执行创建存储过程的 SQL 时，需要通过关键字 `delimiter` 指定SQL语句的结束符。





## 锁

**锁**是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

> MySQL中的锁，按照锁的粒度分，分为以下三类：
>
> - 全局锁：锁定数据库中的所有表。
>
> - 表级锁：每次操作锁住整张表。
>
> - 行级锁：每次操作锁住对应的行数据。



### 全局锁（读锁）

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

> 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的 DDL、DML 全部都处于阻塞状态，但是可以执行 DQL 语句，也就是处于只读状态，而数据备份就是查询操作。
>
> 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。



#### 语法

加全局锁

```SQL
flush tables with read lock;
```

数据备份

```SQL
mysqldump -uroot -p123456 mydatabase > mydatabase.sql
```

释放锁

```SQL
unlock tables;
```



> 特点：数据库中加全局锁，是一个比较重的操作，存在以下问题：.
>
> - 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
> - 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（ binlog ），会导致主从延迟。

在 InnoDB 引擎中，可以在备份时加上参数 `--single-transaction` 参数来完成不加锁的一致性数据备份。

```SQL
mysqldump --single-transaction -uroot –p123456 mydatabase > mydatabase.sql
```



### 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中。

> 对于表级锁，主要分为以下三类：
>
> - 表锁
>
> - 元数据锁（meta data lock，MDL）
>
> - 意向锁

#### 表锁（读与写）

> 对于表锁，分为两类：
>
> - 表共享读锁（read lock）：读锁不会阻塞其他客户端的读，但是会阻塞写。
>
> - 表独占写锁（write lock）：写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

语法：

- 加锁：`lock tables 表名... read/write`。

- 释放锁：`unlock tables / 客户端断开连接 `。

```SQL
lock tables tb_user read / write;
unlock tables;
```



### 元数据锁（表结构）

> 在查询、修改表数据的时候，不允许修改表的结构。（系统自动加锁）

这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的表结构的。

**meta data lock , 元数据锁，简写MDL。**

MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免 DML 与 DDL 冲突，保证读写的正确性。

在MySQL5.5中引入了 MDL，当对一张表进行增删改查的时候，加 MDL 读锁(共享)；当对表结构进行变更操作的时候，加 MDL 写锁(排他)。



当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ 【只有 SELECT】/ SHARED_WRITE），之间是兼容的。

当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。



### 意向锁

> 允许在修改表数据的时候（加上了行锁）再次对表进行加锁（表级锁--意向锁）

为了避免 **DML（数据操作语言）** 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。

在执行 DML 操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。其他客户端在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。

> 分类：
>
> - 意向共享锁( IS ): 由语句`select ... lock in share mode`添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
>
> ```SQL
> select * from user lock in share mode
> ```
>
> 
>
> - 意向排他锁( IX ): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。
>
> ```SQL
> select * from user for update;
> ```
>
> 
>
> 一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。

- 意向共享锁与表读锁是兼容的

- 意向排他锁与表读锁、写锁都是互斥的

  

查看意向锁以及行锁的加锁情况：

```SQL
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```



### 行级锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。

InnoDB 的数据是基于索引组织的，行锁是通过对**索引上的索引项**加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

- 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔离级别下都支持。

- 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下都支持。

- 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在 RR 隔离级别下支持。



#### 行锁

> - InnoDB 的行锁是**针对于索引加的锁**，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时 就会升级为表锁。
> - 针对**唯一索引**进行检索时，对已存在的记录(where 之后的条件)进行等值匹配时，将会自动优化为行锁。
> - 没有索引，不会增加行锁，而是增加表锁

InnoDB 实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。

- 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。（insert、update、delete）

共享锁：

```SQL
SELECT ... LOCK IN SHARE MODE;
```

排他锁：

```SQL
SELECT ... FOR UPDATE;
```

> 注意：
>
> - 单纯的 select 不加锁

|             | S（共享锁） | X（排他锁） |
| ----------- | ----------- | ----------- |
| S(共享锁)   | 兼容        | 冲突        |
| X（排他锁） | 冲突        | 冲突        |



### 间隙锁 & 临键锁

**间隙锁：GAP**

- 索引上的等值查询(唯一索引)，**给不存在的记录加锁时**, 优化为间隙锁 。

- 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key 锁化为间隙锁。

- 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止（InnoDB 会从索引的起始点开始查找，一直访问到不满足查询条件的第一个值为止）。

> 默认情况下，InnoDB在 REPEATABLE READ事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。
>
> **next-key 锁**：next-key 锁是 InnoDB 中的一种锁机制，它是行锁和间隙锁的组合。它用于防止幻读现象的发生，即防止在事务执行期间出现新的行插入到两个已存在的行之间，这可能导致事务看到之前不应该看到的新行。

> 注意：
>
> - 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。





## 事务

> 事务：是一组操作的集合，是一个不可分割的工作单位。事务把所有的操作作为一个整体一起向系统提交或撤销操作请求，那么这些操作要么同时成功，要么同时失败。



- 原子性（Atomicity）：事务是不可分割的最小操作单元，要么全部成功，要么全部失败。
- 一致性（Consistency）：事务完成时，必须使所有的数据都保持一致状态。
- 隔离性（Isolation）：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。
- 持久性（Durability）：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。

而对于这四大特性，实际上分为两个部分。 其中的原子性、一致性、持久化，实际上是由 InnoDB 中的两份日志来保证的，一份是 redo log 日志，一份是 undo log 日志。 而持久性是通过数据库的锁，加上 MVCC 来保证的。



### redo log 重做日志

**重做日志：**记录的是事务提交时数据页的**物理修改**，是用来实现事务的持久性。

- 重做日志缓冲（内存）
- 重做日志文件（磁盘）

该日志文件由两部分组成：重做日志缓冲（redo log buffer）以及重做日志文件（redo log file）,前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都存到该日志文件中，**用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。**

> Redo log 在 InnoDB 存储引擎中用于确保事务的持久性（durability）。当对缓冲池（buffer pool）中的数据进行修改时，InnoDB 会首先将这些修改记录在 redo log buffer 中。redo log buffer 是内存中的一个区域，用于暂存即将写入磁盘的 redo log 记录。

原理：

1. **修改数据页**：当事务对数据进行修改时，InnoDB 会首先在缓冲池中修改数据页，同时记录这些修改到 redo log buffer 中。
2. **事务提交**：当事务提交时，InnoDB 会将 redo log buffer 中的记录写入到 redo log file 中。这个过程称为“flush”，它确保了即使在系统崩溃的情况下，也可以通过 redo log 来恢复数据。
3. **刷新脏页**：InnoDB 会定期将缓冲池中的脏页（即被修改但尚未写入磁盘的数据页）写回磁盘。这个过程称为“checkpoint”。



### uodo log 回滚日志

> 在 insert、update、delete 的时候产生的便于数据回滚的日志。
>
> - 当 insert 的时候，产生的undo log日志只在回滚时需要，在事务提交后，可被立即删除。
> - 而 update、delete 的时候，产生的undo log日志不仅在回滚时需要，在快照读时也需要，不会立即被删除。
>
> 用于记录数据被修改前的信息 , 作用包含两个 : 提供回滚(保证事务的原子性) 和 MVCC (多版本并发控制) 。

undo log 和 redo log 记录物理日志不一样，它是逻辑日志。可以认为当 delete 一条记录时，undo log 中会记录一条对应的 insert 记录，反之亦然，当 update 一条记录时，它记录一条对应相反的 update 记录。当执行 rollback 时，就可以从 undo log 中的逻辑记录读取到相应的内容并进行回滚。

undo log 销毁：undo log 在事务执行时产生，事务提交时，并不会立即删除 undo log，因为这些日志可能还用于MVCC。

undo log 存储：undo log 采用段的方式进行管理和记录，存放在 rollback segment 回滚段中，内部包含1024个 undo log segment。



## MVCC(多版本并发控制)

**当前读：**读取的是记录的最新版本，读取时还要保证其他并发事务不能修改当前记录，会对读取的记录进行加锁。对于我们日常的操作，如：select ... lock in share mode(共享锁)，select ... for update、update、insert、delete(排他锁)都是一种当前读。

**快照读：**简单的select（不加锁）就是快照读，快照读，读取的是记录数据的可见版本，有可能是历史数据，不加锁，是非阻塞读。

- Read Committed：每次select，都生成一个快照读。
- Repeatable Read：开启事务后第一个 select 语句才是快照读的地方。
- Serializable：快照读会退化为当前读。

> 普通的 select 是快照读，而在当前默认的 RR 隔离级别下，**开启事务**后第一个select 语句才是快照读的地方，后面执行相同的 select 语句都是从快照中获取数据，可能不是当前的最新数据，这样也就保证了可重复读。

**MVCC：**全称 Multi-Version Concurrency Control，多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突，快照读为 MySQL 实现 MVCC 提供了一个非阻塞读功能。MVCC 的具体实现，还需要依赖于数据库记录中的三个隐式字段、undo log 日志、readView。



### 隐藏字段

InnoDB在创建表的时候会自动添加三个隐藏字段：

| 隐藏字段    | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| DB_TRX_ID   | 最近修改事务ID，记录插入这条记录或最后依次修改这条记录的事务ID； |
| DB_ROLL_PTR | 回滚指针，指向这条记录的上一个版本，用于配合 undo log，指向上一个版本。 |
| DB_ROW_ID   | 隐藏主键，如果表结构没有指定主键，则会生成改隐藏主键         |

而上述的前两个字段是肯定会添加的， 是否添加最后一个字段DB_ROW_ID，得看当前表有没有主键，如果有主键，则不会添加该隐藏字段。

