---
title: MySQL 索引
date: 2024-08-18
updated: 2024-08-18
category: MySQL
cover: https://tse3-mm.cn.bing.net/th/id/OIP-C.LvJiXW0ldtBwCwC5TBSh4QHaEK?w=321&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---

# MySQL 索引

索引（index）是帮助 MySQL 高效获取数据的数据结构(有序)。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据， 这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。

```SQL
CREATE [UNIQUE | FULLTEXT] INDEX index_name ON table_name (index_col_name,…);
# 查看表里面有哪些索引
SHOW IDNEX FROM TABLE_NAME;
DROP INDEX index_name ON table_name;
```



#### 特点

| 优势                                                         | 劣势                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 提高数据检索的效率，降低数据库的 IO 成本                     | 索引列也是要占用空间的。                                     |
| 通过索引列对数据进行排序，降低数据排序的成本，降低 CPU 的消耗。 | 索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行 INSERT、UPDATE、DELETE 时，效率降低。 |

MySQL的索引是在存储引擎层实现的，不同的存储引擎有不同的索引结构，主要包含以下几种：

| 索引结构            | 描述                                                         |
| ------------------- | ------------------------------------------------------------ |
| B+Tree索引          | 最常见的索引类型，大部分引擎都支持 B+ 树索引                 |
| Hash索引            | 底层数据结构是用哈希表实现的, 只有精确匹配索引列的查询才有效, 不支持范围查询 |
| R-tree(空间索引）   | 空间索引是MyISAM引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少 |
| Full-text(全文索引) | 是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene,Solr,ES |



#### 为啥不选二叉树作为索引？

选择二叉树作为索引结构，会存在以下缺点：

- 顺序插入时，会形成一个链表，查询性能大大降低。

- 大数据量情况下，层级较深，检索速度慢。



#### B-Tree

B-Tree，B树是一种多叉路衡查找树，相对于二叉树，B树每个节点可以有多个分支，即多叉。

以一颗最大度数（max-degree）为5(5阶)的b-tree为例，那这个B树每个节点最多存储4个key，5个指针。

特点：

- 5阶的 B 树，每一个节点最多存储4个 key，对应5个指针（每个关键字都夹在两个指针之间）。

- 一旦节点存储的 key 数量到达 5，就会裂变，中间元素向上分裂。

- 在 B 树中，非叶子节点和叶子节点都会存放数据。



#### B+Tree

B+Tree 是 B-Tree 的变种

B+Tree 的中间节点值存储索引，不存储数据，存储数据的是叶子节点。

> B+Tree 与 B-Tree 相比，主要有以下三点区别：
>
> - 所有的数据都会出现在叶子节点。
> - 叶子节点形成一个单向链表。
> - 非叶子节点仅仅起到**索引数据**作用，具体的数据都是在叶子节点存放的。



MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能，利于排序。

> 为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？
>
> - 相对于二叉树，层级更少，搜索效率高；
> - 对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低；
> - 相对Hash索引，B+tree支持范围匹配及排序操作；



### 索引分类

在 MySQL 数据库，将索引的具体类型主要分为以下几类：主键索引、唯一索引、常规索引、全文索引。

| 分类     | 含义                                                 | 特点                     | 关键字   |
| -------- | ---------------------------------------------------- | ------------------------ | -------- |
| 主键索引 | 针对于表中主键创建的索引                             | 默认自动创建, 只能有一个 | PRIMARY  |
| 唯一索引 | 避免同一个表中某数据列中的值重复                     | 可以有多个               | UNIQUE   |
| 常规索引 | 快速定位特定数据                                     | 可以有多个               |          |
| 全文索引 | 全文索引查找的是文本中的关键词，而不是比较索引中的值 | 可以有多个               | FULLTEXT |



#### 聚集索引（聚簇索引） & 二级索引

在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：

| 分类                        | 含义                                                         | 特点                 |
| --------------------------- | ------------------------------------------------------------ | -------------------- |
| 聚集索引（Clustered Index） | 将**数据存储与索引**放到一块，索引结构的叶子节点保存了行数据 | 必须有，且只能由一个 |
| 二级索引（Secondary Index） | 将数据与索引分开存储，**索引结构的叶子节点关联的是对应的主键**。因此查询了二级索引需要回表。 | 可以存在多个         |

![聚集索引 和 二级索引](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240821122338264.png)

聚集索引选取规则：

- 如果存在主键，主键索引就是聚集索引。
- 如果不存在主键，将使用第一个唯一（UNIQUE）索引作为聚集索引。
- 如果表没有主键，或没有合适的唯一索引，则 InnoDB 会自动生成一个 row_id 作为隐藏的聚集索引。
  - 这就是如果创建表的时候没有主键，根据什么构造 B+树


> 先到二级索引中查找数据，找到主键值，然后再到聚集索引中根据主键值，获取数据的方式，就称之为回表查询。(根据二级索引查数据比 id 慢)



### 最左匹配原则

如果索引了多列（联合索引），要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将会部分失效(后面的字段索引失效)。

通过创建索引

```SQL
CREATE INDEX INDEX_EMP ON EMP(ename,job,deptno);
```

之后通过 explain 分析可以看出：

![explain 查询](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240819154541676.png)

> 注意：
>
> -  最左前缀法则中指的最左边的列，是指在查询时，联合索引的最左边的字段(即是第一个字段)必须存在，与我们编写SQL时，条件编写的先后顺序无关。
>
> ![最左匹配](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240819154835875.png)



### 范围查询

联合索引中，出现范围查询(>,<)，范围查询右侧的列索引失效（不包含使用 范围查询的列【索引仍然生效】）。

当范围查询使用>= 或 <= 时，走联合索引。

> 在业务允许的情况下，尽可能的使用类似于 >= 或 <= 这类的范围查询，而避免使用 > 或 <



### 索引失效的情况

- 在索引上进行运算操作

- 字符串不加引号

- 头部模糊查询（尾部模糊查询 不会失效）

- or 连接条件有一方没有索引（两侧都是索引才会生效）

- 数据分布影响（索引比全表扫描慢的话，不走索引）

  > MySQL 在查询时，会评估使用索引的效率与走全表扫描的效率，如果走全表扫描更快，则放弃索引，走全表扫描。 因为索引是用来索引少量数据的，如果通过索引查询返回大批量的数据，则还不如走全表扫描来的快，此时索引就会失效。



### SQL 提示

SQL提示，是优化数据库的一个重要手段，简单来说，就是在 SQL 语句中加入一些人为的提示来达到优化操作的目的。

> 在查询数据时指定使用哪个索引？

```SQL
# use 建议 MySQL 使用哪一个索引（MySQL内部还会再次进行评估）
SELECT * FROM EMP USE INDEX(INDEX_EMP) WHERE ENAME = 'SMITH';
# 忽略指定索引 ignore
SELECT * FROM EMP IGNORE INDEX(INDEX_EMP) WHERE ENAME = 'SMITH';
# 强制使用索引 forcw
SELECT * FROM EMP FORCE INDEX(INDEX_EMP) WHERE ENAME = 'SMITH';
```



### 单列索引与联合索引

单列索引：即一个索引只包含单个列。

联合索引：即一个索引包含了多个列。

```SQL
CREATE INDEX index_name ON table_name(field1);
CREATE INDEX index_name ON table_name(field1, field2);
```

> 在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。



### 覆盖索引

**覆盖索引：**指查询使用了索引，并且需要返回的列，在该索引（联合索引）中已经全部能够找到 。

尽量使用覆盖索引，减少select *。 

| Extra                    | 含义                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Using where; Using index | 查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据 |
| Using index condition    | 查找使用了索引，但是需要回表查询数据                         |



### 前缀索引

当字段类型为字符串（varchar，text，longtext等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘 IO， 影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。

```SQL
CREATE INDEX INDEX_XXXX ON table_name(column(n)); 
```



#### 扫描时候创建索引

1). 针对于数据量较大，且查询比较频繁的表建立索引。

2). 针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引。

3). 尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。

4). 如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。

5). 尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。

6). 要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。

7). 如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含 NULL 值时，它可以更好地确定哪个索引最有效地用于查询。