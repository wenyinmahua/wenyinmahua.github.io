---
title: Java 实现锁
date: 2023-04-01
updated: 2024-05-23
comments: true
category: java
tags: 
  - Lock
---
# 乐观锁和悲观锁

解决多线程安全问题就是加锁，通常有**乐观锁**和**悲观锁**两种方式：

![image-20240725235622622](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240725235622622.png)

## 悲观锁：

 悲观锁可以实现对于数据的串行化执行，比如syn，和 lock 都是悲观锁的代表，同时，悲观锁中又可以再细分为公平锁，非公平锁，可重入锁，等等.（增加同步锁，让线程串行执行，确保同一时刻只有一个线程修改资源）

- 例如 Synchronized、Lock 都属于悲观锁。

> - 优点：简单粗暴
>
> - 缺点：性能一般



悲观锁是直接加上 synchronized ，是线程由并行变成并发

```java
synchronized(this){
     // 业务逻辑代码
}
```

如果有用户 id,可以通过用户 id 减小锁的粒度
```java
// userId.toString() 拿到的对象实际上是不同的对象，new出来的对象
// intern() 方法是从常量池中拿到数据
synchronized(userId.toString().intern()){
    // 业务逻辑代码
}
```



## 乐观锁：

 乐观锁：以为线程安全问题不一定会发生，因此不加锁，只是在更新数据时判断有没有其他线程对数据做了修改。（不加锁，在更新时判断是否有其他线程在修改）。会有一个版本号，每次操作数据会对版本号+1，再提交回数据时，会去校验是否比之前的版本大1 ，如果大1 ，则进行操作成功，这套机制的核心逻辑在于，如果在操作过程中，版本号只比原来大1 ，那么就意味着操作过程中没有人对他进行过修改，他的操作就是安全的，如果不大1，则数据被修改过，当然乐观锁还有一些变种的处理方式比如cas  "Compare-and-Swap"（比较并交换）。



- 如果没有修改则认为是安全的，自己才更新数据；
- 如果已经被其他线程修改说明发生了安全问题，此时可以重试或异常。

> - 优点：性能好
> - 缺点：存在成功率低的问题（通过分段锁（分批加锁）
>   - 可以提高成功率，把数据资源分成几份，在多张表里面取获取数据资源，成功率提高了 10 倍[每次锁定的资源少]）



### 乐观锁解决商品超卖问题：

**CAS法：**Compare And Set，对数据库中数据进行修改时，先检查数据库里面的数据是否和查询的时候一致（或者是否符合修改的条件，如库存 > 0），如果一致（符合修改条件）说明没有被其他线程修改，则可以修改，否则说明已经被其他线程修改了，需要重试或者报错。

解决方案一：

```java
boolean success = seckillVoucherService.update()
            .setSql("stock= stock -1") //set stock = stock -1
            .eq("voucher_id", voucherId).eq("stock",voucher.getStock()).update(); //where id = ？ and stock = ?
```

解决方案二：

```java
boolean success = seckillVoucherService.update()
            .setSql("stock= stock -1")
            .eq("voucher_id", voucherId).update().gt("stock",0); //where id = ? and stock > 0
```



# 分布式锁

**分布式锁：**满足分布式系统或集群模式下多进程可见并且互斥的锁（单机情况下通过 JVM 的锁监视器，集群需要自己设计[redis]，因为每一个 JVM 都有自己的锁监视器）

- 多线程可见
- 互斥
- 高可用：大多数情况下获取锁都是成功的
- 高性能：高并发
- 安全性：释放锁

通过加锁可以解决单机情况下的一人一单安全问题，但是在集群模式下就不行了。通过分布式锁来实现。

高并发 -->  负载均衡  -->  集群（部署到多态机器上）



分布式锁的核心是实现多进程之间的互斥，而满足这一点的方式有多种，常见的有三种：

|        |            MySQL            |           Redis           |            Zookeeper             |
| :----: | :-------------------------: | :-----------------------: | :------------------------------: |
|  互斥  | 利用 mysql 本身的互斥锁机制 | 利用 setnx 这样的互斥命令 | 利用节点的唯一性和有序性实现互斥 |
| 高可用 |         好（主从）          |     好（主从、集群）      |                好                |
| 高性能 |            一般             |            好             |               一般               |
| 安全性 |    p断开连接，自动释放锁    | 利用锁超时时间，到期释放  |    临时节点，断开连接自动释放    |

