---
title: 第二章 线性表
date: 2023-02-12
updated: 2023-02-12
comments: true
category: 数据结构与算法
tags:
  - 408
cover: https://tse4-mm.cn.bing.net/th/id/OIP-C.-Gua19mx8sZHc4Y_bxaATQHaEK?w=308&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---

# 线性表

## 1. 线性表的定义和基本操作

### 1.1 线性表的定义

**线性表：**指的是具有**相同类型**的 n(n>=0) 个**数据元素**的**有限序列。**其中 n 为表长，当 n = 0 时，线性表是一张空表。

线性表是一种逻辑结构，表示表中元素之间**一对一**的相邻关系。

线性表的展示：

![线性表](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241112195035995.png)

线性表的特点如下：

- 表中的元素个数有限；
- 表中的元素具有逻辑上的顺序关系，即具有先后关系；
- 表中元素都是数据元素，且每个元素都是单个元素；
- 表中元素的数据类型都相同，意味着每个元素占有相同大小的存储空间。



### 1.2 线性表的操作

线性表的操作包含线性表的初始化、获取线性表的长度、按值查找、按位查找、插入、删除、输出、判空、销毁等等操作。



## 2. 线性表的顺序表示

线性表的顺序表示又称为**顺序表**，使用一组连续的存储单元依次存储线性表中的数据元素，从而使得**逻辑上相邻的两个元素在物理位置上也相邻**。

顺序表中的任意一个数据元素都可以**随机存取**（通过首地址和元素序号可在时间O(1)内找到指定的元素）；

顺序表的**存储密度高**，每个结点只存储数据元素；

顺序表逻辑上相邻的元素在物理上也相邻，所以插入和删除操作时，可能需要移动大量元素。



```C
#include <stdio.h>
#include <stdlib.h>  // 包含 malloc 和 free 的头文件

#define InitSize 100
// 链表结构体
typedef struct {
    int *data;
    int maxSize;
    int length;
} SeqList;

// 初始化顺序表
void Init(SeqList *L) {
    L->data = (int *)malloc(sizeof(int) * InitSize);
    if (L->data == NULL) {
        printf("内存分配失败\n");
        exit(1);  // 分配失败时退出程序
    }
    L->maxSize = InitSize;
    L->length = 0;
}

// 插入元素
bool Insert(SeqList *L, int i, int insertValue) {
    if (i < 1 || i > L->length + 1) {
        return false;  // 插入位置不合法
    }
    if (L->length >= L->maxSize) {
        return false;  // 顺序表已满
    }
    for (int j = L->length; j >= i; j--) {
        L->data[j] = L->data[j - 1];  // 向后移动元素
    }
    L->data[i-1] = insertValue;  // 插入新元素
    L->length++;  // 更新长度
    return true;
}

// 删除元素
bool Delete(SeqList *L, int i) {
    if (i < 1 || i > L->length) {
        return false;  // 删除位置不合法
    }
    for (int j = i; j < L->length; j++) {
        L->data[j - 1] = L->data[j];  // 向前移动元素
    }
    L->length--;  // 更新长度
    return true;
}

// 遍历顺序表
void Traverse(SeqList *L) {
    printf("顺序表内容: ");
    for (int i = 0; i < L->length; i++) {
        printf("%d ", L->data[i]);
    }
    printf("\n");
}

// 按值查找元素
int Search(SeqList *L, int value) {
    for (int i = 0; i < L->length; i++) {
        if (L->data[i] == value) {
            return i + 1;  // 返回元素的位置（从1开始）
        }
    }
    return -1;  // 未找到元素
}

int main() {
    SeqList L;
    int n;
    int insertValue;
    Init(&L);
	printf("请输入插入的数字个数：");
	scanf("%d",&n);
	for(int i = 1; i <= n; i++){
		scanf("%d",&insertValue);
		Insert(&L,i,insertValue);
	}
    // 遍历顺序表
    Traverse(&L);

    // 测试按值查找操作
    int position = Search(&L, 2);
    if (position != -1) {
        printf("找到元素 2，位置为: %d\n", position);
    } else {
        printf("未找到元素 2\n");
    }

    // 释放分配的内存
    free(L.data);

    return 0;
}
```



## 3. 线性表的链式表示

线性表的链式表示又叫做**单链表**，在逻辑上相邻的元素，不要求在物理存储方面相邻，通过“链”建立元素之间的逻辑关系。因此插入和删除元素的时候，不需要移动元素，而只需要修改指针。

单链表通过一组任意的存储单元来存储线性表中的数据元素，为了建立数据元素之间的线下关系，对每个链表节点，除存放元素本身的信息之外，还需要存放指向其后继的指针。

![链表](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241113182902846.png)

```C
#include <stdio.h>
#include <stdlib.h>  // 包含 malloc 和 free 的头文件

// 定义链表节点
typedef struct Node {
    int data;
    struct Node *next;
} Node;

// 定义链表
typedef struct {
    Node *head;
    int length;
} LinkedList;

// 初始化链表
void Init(LinkedList *L) {
    L->head = NULL;
    L->length = 0;
}

// 插入元素
bool Insert(LinkedList *L, int i, int insertValue) {
    if (i < 1 || i > L->length + 1) {
        return false;  // 插入位置不合法
    }

    Node *newNode = (Node *)malloc(sizeof(Node));
    if (newNode == NULL) {
        printf("内存分配失败\n");
        return false;
    }
    newNode->data = insertValue;
    newNode->next = NULL;

    if (i == 1) {
        newNode->next = L->head;
        L->head = newNode;
    } else {
        Node *current = L->head;
        for (int j = 1; j < i - 1; j++) {
            current = current->next;
        }
        newNode->next = current->next;
        current->next = newNode;
    }

    L->length++;
    return true;
}

// 删除元素
bool Delete(LinkedList *L, int i) {
    if (i < 1 || i > L->length) {
        return false;  // 删除位置不合法
    }

    Node *toDelete;
    if (i == 1) {
        toDelete = L->head;
        L->head = L->head->next;
    } else {
        Node *current = L->head;
        for (int j = 1; j < i - 1; j++) {
            current = current->next;
        }
        toDelete = current->next;
        current->next = toDelete->next;
    }

    free(toDelete);
    L->length--;
    return true;
}

// 遍历链表
void Traverse(LinkedList *L) {
    Node *current = L->head;
    printf("链表内容: ");
    while (current != NULL) {
        printf("%d ", current->data);
        current = current->next;
    }
    printf("\n");
}

// 按值查找元素
int Search(LinkedList *L, int value) {
    Node *current = L->head;
    int index = 1;
    while (current != NULL) {
        if (current->data == value) {
            return index;  // 返回元素的位置（从1开始）
        }
        current = current->next;
        index++;
    }
    return -1;  // 未找到元素
}

int main() {
    LinkedList L;
    Init(&L);

    // 测试插入操作
    if (Insert(&L, 1, 2)) {
        printf("插入成功\n");
    } else {
        printf("插入失败\n");
    }

    if (Insert(&L, 2, 3)) {
        printf("插入成功\n");
    } else {
        printf("插入失败\n");
    }

    // 测试删除操作
    if (Delete(&L, 1)) {
        printf("删除成功\n");
    } else {
        printf("删除失败\n");
    }

    // 测试遍历操作
    Traverse(&L);

    // 测试按值查找操作
    int position = Search(&L, 3);
    if (position != -1) {
        printf("找到元素 3，位置为: %d\n", position);
    } else {
        printf("未找到元素 3\n");
    }

    // 释放分配的内存
    Node *current = L.head;
    while (current != NULL) {
        Node *temp = current;
        current = current->next;
        free(temp);
    }

    return 0;
}
```



















































