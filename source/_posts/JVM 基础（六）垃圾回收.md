---
title: JVM 基础（六）垃圾回收
date: 2024-09-01
updated: 2024-09-03
category: JVM
tags:
  - 笔记
cover: https://tse2-mm.cn.bing.net/th/id/OIP-C.iK1EFamgj6pjOvuhROEFNAHaEK?w=305&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7

---



# JVM 基础（六）垃圾回收

> - 现实生活中的垃圾指的是失去使用价值的废弃物品；
>
> - JVM 中的垃圾指的是不再被使用的 Java 对象；
> - 垃圾回收器回收的是线程不共享部分的内存，这些内存都是伴随着线程的创建而创建，线程的销毁而销毁。
>   - 程序计数器
>   - Java 虚拟机栈
>   - 本地方法栈
> - 方法的栈帧在执行完方法之后就会自动弹出栈并释放掉对应的内存。这一部分不需要垃圾回收器进行回收。

内存泄漏指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出。   

Java 中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection 简称 GC）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责**对堆上的内存进行回收**。

垃圾回收器如果发现**某个对象不再使用**，就可以回收该对象。





## 自动与手动垃圾回收的区别

- 自动垃圾回收，自动根据对象是否使用由虚拟机来回收对象
  - 优点：降低程序员实现难度、降低对象回收bug的可能性
  - 缺点：程序员无法控制内存回收的及时性
- 手动垃圾回收，由程序员编程实现对象的删除
  - 优点：回收及时性高，由程序员把控回收的时机
  - 缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题



## 1.方法区的回收

> 方法区中能回收的内容主要就是**不再使用的类。**

判定一个类可以被卸载。需要**同时**满足下面三个条件：

1. 此类所有实例对象都已经被回收，在堆中不存在任何该类的**实例**对象以及**子类**对象。
2. 加载该类的**类加载器**已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用。

如果需要手动触发垃圾回收，可以调用 `System.gc()` 方法。

> 注意：
>
> - 调用 `System.gc()` 方法并不一定会立即回收垃圾，仅仅是向 Java 虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收 Java 虚拟机会自行判断。



## 2.对象的回收

垃圾回收器要回收对象的第一步就是判断哪些对象可以回收。

- Java中的对象是否能被回收，是根据对象是否被引用来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。

判断对象是否可以回收，主要有两种方式：**引用计数法**和**可达性分析法**。



### 引用计数法

引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。

引用计数法的缺点主要有两点：

1.每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响

2.存在循环引用问题，所谓循环引用就是当 A 引用 B，B 同时引用 A 时会出现对象无法回收的问题。



### 可达性分析法

Java 使用的是**可达性分析算法**来判断对象是否可以被回收。

可达性分析将对象分为两类：垃圾回收的根对象（GC Root）和普通对象，对象与对象之间存在引用关系。

可达性分析算法指的是**如果从某个到GC Root对象是可达的，对象就不可被回收。**

哪些对象被称之为GC Root对象呢？

- 线程 Thread 对象，引用线程栈帧中的方法参数、局部变量等。
- 系统类加载器加载的 java.lang.Class 对象，引用类中的静态变量。
- 监视器对象，用来保存同步锁synchronized关键字持有的对象。
- 本地方法调用时使用的全局对象。



## 3. 常见的引用对象

可达性算法中描述的对象引用，一般指的是强引用，即是 GCRoot 对象对普通对象有引用关系，只要这层关系存在，普通对象就不会被回收。除了强引用之外，Java中还设计了几种其他引用方式：

- 软引用
- 弱引用
- 虚引用
- 终结器引用



## 4. 垃圾回收算法

Java是如何实现垃圾回收的呢？简单来说，垃圾回收要做的有两件事：

1. 找到内存中存活的对象；
2. 释放不再存活对象的内存，使得程序能再次利用这部分空间 ；

### 垃圾回收算法的分类

![垃圾回收算法](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/ae0153ae-4518-458f-a3d7-896a8d8e7076.png)



### 垃圾回收算法的评价标准

Java 垃圾回收过程会通过单独的 GC 线程来完成，但是不管使用哪一种 GC 算法，**都会有部分阶段需要停止所有的用户线程**。这个过程被称之为 `Stop The World` 简称 `STW`，如果 STW 时间过长则会影响用户的使用。

如下图，用户代码执行和垃圾回收执行让用户线程停止执行（STW）是交替执行的。

![垃圾会后和用户代码交替执行](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/8b1e52f6-752e-4933-8d42-6abb624b5fa5.png)

所以判断GC算法是否优秀，可以从三个方面来考虑：

1. 吞吐量

吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 /（执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。

![GC 算法吞吐量计算](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/535cdfcc-99ce-4a76-9455-ba9586f630fa.png)

2. 最大暂停时间

最大暂停时间指的是所有在垃圾回收过程中的 STW 时间最大值。比如如下的图中，黄色部分的 STW 就是最大暂停时间，显而易见上面的图比下面的图拥有更少的最大暂停时间。最大暂停时间越短，用户使用系统时受到的影响就越短。

![最大暂停时间](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/2a8f0cbc-a75f-4d45-b4b5-c6cd6304ad44.png)

3. 堆使用效率

不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。

上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间不可兼得。

一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。

![不同 GC 算法堆使用的效率](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/ea32e9db-fb97-42a7-a96b-1c675e99b43b.png)



没有一个垃圾回收算法能兼顾上述三点评价标准，所以不同的垃圾回收算法它的侧重点是不同的，适用于不同的应用场景。

### GC 算法

#### 1. 标记清除算法

标记清除算法的核心思想分为两个阶段：

1.标记阶段，将所有存活的对象进行标记。Java 中使用可达性分析算法，从 GC Root 开始通过**引用链**遍历出所有存活对象。

2.清除阶段，从内存中删除没有被标记也就是非存活对象。

优点：实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。

缺点：

1. 碎片化问题
   - 垃圾回收后，内存仍然有碎片问题
2. 分配速度慢
   - 要遍历链表找到合适的内存空间



#### 2.复制算法

> 堆内存劈成两半，一半空间可用，叫 `From`，一半空间不可用，叫`To`；
>
> 当进行垃圾回收时，
>
> 1. 将 From 区域的存活对象复制到 To 区域，清空 From 区域
> 2. 将两块区域 From 和 To 名字互换
> 3. 重复上述步骤

优点：

- 吞吐量高，复制算法只需要遍历一次存活对象复制到 To 空间即可，比标记-整理算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法，因为标记清除算法不需要进行对象的移动；
- 不会发生碎片化，复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。

缺点：

- 内存使用率低，每次只能让一半的内存空间来为常见对象使用。



### 3. 标记整理算法

标记整理算法也叫标记压缩算法，是对标记清理算法中容易产生内存碎片问题的一种解决方案。

核心思想分为两个阶段：

1. 标记阶段，将所有存活的对象进行标记。Java 中使用可达性分析算法，从 GC Root 开始通过引用链遍历出所有存活对象。

2. 整理阶段，将存活对象移动到堆的一端。清理掉存活对象的内存空间。

![标记整理算法](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/cc7da1a7-54f9-4646-a39e-85363a07dc71.png)

优点：

- 内存使用效率高，整个堆内存都可以使用，不会像复制算法只能使用半个堆内存
- 不会发生碎片化，在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间

缺点：

整理阶段的效率不高，整理算法有很多种，比如 Lisp2 整理算法需要对整个堆中的对象搜索 3 次，整体性能不佳。可以通过 Two-Finger、表格算法、ImmixGC 等高效的整理算法优化此阶段的性能。



### 4. 分代垃圾回收算法

分代垃圾回收将整个内存区域划分为年轻代和老年代：

![分代垃圾回收算法](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/d865fdac-c298-4431-b5ff-5ee63a2d93bd.png)

`-XX:+UseSerialGC` 参数使用分代回收的垃圾回收器，运行程序。



另外还可以选择的虚拟机参数如下

| 参数名                        | 参数含义                                                     | 示例                                                    |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------------------------------- |
| -Xms                          | 设置堆的最小和初始大小，必须是1024倍数且大于1MB              | 比如初始大小6MB的写法： -Xms6291456 -Xms6144k -Xms6m    |
| -Xmx                          | 设置最大堆的大小，必须是1024倍数且大于2MB                    | 比如最大堆80 MB的写法： -Xmx83886080 -Xmx81920k -Xmx80m |
| -Xmn                          | 新生代的大小                                                 | 新生代256 MB的写法： -Xmn256m -Xmn262144k -Xmn268435456 |
| -XX:SurvivorRatio             | 伊甸园区和幸存区的比例，默认为8 新生代1g内存，伊甸园区800MB,S0和S1各100MB | 比例调整为4的写法：-XX:SurvivorRatio=4                  |
| -XX:+PrintGCDetailsverbose:gc | 打印GC日志                                                   | 无                                                      |



#### 详情

1. 分代回收时，创建出来的对象，首先会被放入Eden伊甸园区。
   ![将创建的对象放入伊甸园区](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/3cfbc039-376c-4f1e-aaba-b16b8682ffb4.png)

2. 随着对象在 Eden 区越来越多，**如果 Eden 区满**，新创建的对象已经无法放入，就会触发年轻代的GC，称为 Minor GC 或者 Young GC。

   Minor GC 会把需要 eden 中和 From 需要回收的对象回收，把没有回收的对象放入 To 区。
   ![回收垃圾对象](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/f1458f2b-adef-4650-b79e-f4ab7627c876.png)

3. 接下来，S0 会变成 To 区，S1 变成 From 区。当 eden 区满时再往里放入对象，依然会发生 Minor GC。
   ![继续向 eden 区放入对象](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/dcacd013-76b6-4649-8d79-ad907e52949e.png)

   此时会回收 eden 区和 S1(from) 中的对象，并把 eden 和 from 区中剩余的对象放入 S0。
   ![对象回收](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/a596bc84-271b-4b9f-99a2-46e52f49479e.png)

注意：每次 Minor GC 中都会为对象记录他的年龄，初始值为0，每次GC完加1。

4. 如果 Minor GC 后对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。

![对象年龄达到阈值，即将放入老年代](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/d0cb9cb2-8ac5-41ab-b642-b42754d7083f.png)

![对象放入老年代](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/baf18695-623a-4497-bb07-c5136e457fd1.png)

当**老年代中空间不足**，无法放入新的对象时，先尝试 `Minor GC`，如果还是不足，就会触发 `Full GC`，Full GC 会对整个堆进行垃圾回收。

如果 Full GC 依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出`Out Of Memory`异常。

![Out Of Memory 异常](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/2226fedc-b3f1-4863-be51-7d6f840cf6dd.png)



## 5. 垃圾回收器

为什么分代 GC 算法要把堆分成年轻代和老年代？首先我们要知道堆内存中对象的特性：

- 系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。
- 老年代中会存放长期存活的对象，比如 Spring 的大部分 bean 对象，在程序启动之后就不会被回收了。
- 在虚拟机的默认设置中，新生代大小要远小于老年代的大小。



分代GC算法将堆分成年轻代和老年代主要原因有：

1. 可以通过调整年轻代和老年代的**比例**来适应不同类型的应用程序，提高内存的利用率和性能。

2. 新生代和老年代**使用不同的垃圾回收算法**，新生代一般选择**复制算法**，老年代可以选择**标记-清除**和**标记-整理**算法，由程序员来选择灵活度较高。
3. 分代的设计中允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full gc)，STW 时间就会减少。



垃圾回收器是垃圾回收算法的具体实现。

由于垃圾回收器分为年轻代和老年代，除了 G1 之外其他垃圾回收器必须成对组合进行使用。

具体的关系图如下：

![垃圾回收](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/4ebc3f7f-8a0d-4608-8988-b2775853132d.png)



### 年轻代-Serial垃圾回收器

Serial 是一种单线程串行回收年轻代的垃圾回收器。

**回收年代和算法：**

年轻代

复制算法

**优点**

单CPU处理器下吞吐量非常出色

**缺点**

多 CPU 下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**

Java 编写的客户端程序或者硬件配置有限的场景



### 老年代-SerialOld垃圾回收器

SerialOld是Serial垃圾回收器的老年代版本，采用单线程串行回收

`-XX:+UseSerialGC` 新生代、老年代都使用串行回收器。

**回收年代和算法：**

老年代

标记-整理算法

**优点**

单CPU处理器下吞吐量非常出色

**缺点**

多CPU下吞吐量不如其他垃圾回收器，堆如果偏大会让用户线程处于长时间的等待

**适用场景**

与Serial垃圾回收器搭配使用，或者在CMS特殊情况下使用



### 年轻代-ParNew垃圾回收器

ParNew垃圾回收器本质上是对Serial在多CPU下的优化，使用多线程进行垃圾回收

`-XX:+UseParNewGC` 新生代使用ParNew回收器， 老年代使用串行回收器

**回收年代和算法：**

年轻代

复制算法

**优点**

多 CPU 处理器下停顿时间较短

**缺点**

吞吐量和停顿时间不如G1，所以在JDK9之后不建议使用

**适用场景**

 JDK8 及之前的版本中，与CMS老年代垃圾回收器搭配使用



### 老年代- CMS(Concurrent Mark Sweep)垃圾回收器

CMS 垃圾回收器关注的是系统的暂停时间，允许用户线程和垃圾回收线程在某些步骤中同时执行，减少了用户线程的等待时间。

参数：`XX:+UseConcMarkSweepGC`

**回收年代和算法：**

老年代

标记-清除算法

**优点**

系统由于垃圾回收出现的停顿时间较短，用户体验好

**缺点**

1、内存碎片问题

2、退化问题

3、浮动垃圾问题

**适用场景**

 大型的互联网系统中用户请求数据量大、频率高的场景，比如订单接口、商品接口等

CMS执行步骤：

1.初始标记，用极短的时间标记出GC Roots能直接关联到的对象。

2.并发标记,   标记所有的对象，用户线程不需要暂停。

3.重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。

4.并发清理，清理死亡的对象，用户线程不需要暂停。

缺点：

1、CMS使用了标记-清除算法，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。这样会导致用户线程暂停，可以使用-XX:CMSFullGCsBeforeCompaction=N 参数（默认0）调整N次Full GC之后再整理。

2.、无法处理在并发清理过程中产生的“浮动垃圾”，不能做到完全的垃圾回收。

3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代。





































