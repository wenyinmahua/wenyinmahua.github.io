---
title: MySQL 锁机制
date: 2024-08-18
updated: 2024-08-18
category: MySQL
cover: https://tse3-mm.cn.bing.net/th/id/OIP-C.LvJiXW0ldtBwCwC5TBSh4QHaEK?w=321&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---

# 锁

**锁**是计算机协调多个进程或线程并发访问某一资源的机制。在数据库中，除传统的计算资源（CPU、RAM、I/O）的争用以外，数据也是一种供许多用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。从这个角度来说，锁对数据库而言显得尤其重要，也更加复杂。

### 锁的分类

#### 按粒度分

MySQL中的锁，按照锁的**粒度**分，分为以下三类：

- 全局锁：锁定数据库中的所有表。（只读，用于备份场景）

- 表级锁：每次操作锁住整张表。（读取整个表不需要频繁更新）

- 行级锁：每次操作锁住对应的行数据。（高并发、更新操作频繁）



#### 按模式分

- 乐观锁：假设冲突发生的概率较低，在提交时检查数据是否被其他事务修改，若未被修改则提交，否则回滚。MySQL 中没有内置的乐观锁实现，但可以通过版本号或时间戳等字段实现。（读多写少）
- 悲观锁：假设冲突发生的概率较高，直接对数据加锁，其他事务必须等待锁释放后才能访问。行级锁就是一种悲观锁。



#### 按属性分

- 共享锁（S 锁）：允许多个事务同时读取同一资源，但不允许修改。
- 排他锁（X 锁）：阻止其他事务对已锁定资源进行读写操作，通常用于修改数据。



#### 其他锁

- 意向锁：为了提高加表锁的效率，当事务对表中的数据行加锁时，会同时给表加上意向锁，表明表中有行锁存在。
- 间隙锁：锁定两个值之间的空隙，防止其他事务在间隙中插入或删除记录，主要解决幻读问题。
- 临键锁：可以理解为间隙锁加记录锁，其他事务既不能更改锁定的数据，也不能插入。



### 全局锁（读锁）

全局锁就是对整个数据库实例加锁，加锁后整个实例就处于只读状态，后续的 DML 的写语句，DDL 语句，已经更新操作的事务提交语句都将被阻塞。

其典型的使用场景是做**全库的逻辑备份**，对所有的表进行锁定，从而获取一致性视图，保证数据的完整性。

> 对数据库进行进行逻辑备份之前，先对整个数据库加上全局锁，一旦加了全局锁之后，其他的 DDL、DML 全部都处于阻塞状态，但是可以执行 DQL 语句，也就是处于只读状态，而数据备份就是查询操作。
>
> 那么数据在进行逻辑备份的过程中，数据库中的数据就是不会发生变化的，这样就保证了数据的一致性和完整性。



#### 语法

加全局锁

```SQL
flush tables with read lock;
```

数据备份

```SQL
mysqldump -uroot -p123456 mydatabase > mydatabase.sql
```

释放锁

```SQL
unlock tables;
```



> 特点：数据库中加全局锁，是一个比较重的操作，存在以下问题：.
>
> - 如果在主库上备份，那么在备份期间都不能执行更新，业务基本上就得停摆。
> - 如果在从库上备份，那么在备份期间从库不能执行主库同步过来的二进制日志（ binlog ），会导致主从延迟。

在 InnoDB 引擎中，可以在备份时加上参数 `--single-transaction` 参数来完成不加锁的一致性数据备份。

```SQL
mysqldump --single-transaction -uroot –p123456 mydatabase > mydatabase.sql
```



### 表级锁

表级锁，每次操作锁住整张表。锁定粒度大，发生锁冲突的概率最高，并发度最低。应用在 MyISAM、InnoDB、BDB 等存储引擎中。

> 对于表级锁，主要分为以下三类：
>
> - 表锁
>
> - 元数据锁（meta data lock，MDL）
>
> - 意向锁

#### 表锁（读与写）

> 对于表锁，分为两类：
>
> - 表共享读锁（read lock）：读锁不会阻塞其他客户端的读，但是会阻塞写。
>
> - 表独占写锁（write lock）：写锁既会阻塞其他客户端的读，又会阻塞其他客户端的写。

语法：

- 加锁：`lock tables 表名... read/write`。

- 释放锁：`unlock tables / 客户端断开连接 `。

```SQL
lock tables tb_user read / write;
unlock tables;
```



### 元数据锁（表结构）

> 在查询、修改表数据的时候，不允许修改表的结构。（系统自动加锁）

这里的元数据，可以简单理解为就是一张表的表结构。 也就是说，某一张表涉及到未提交的事务时，是不能够修改这张表的**表结构**的。

**meta data lock , 元数据锁，简写MDL。**

MDL 加锁过程是系统自动控制，无需显式使用，在访问一张表的时候会自动加上。MDL 锁主要作用是维护表元数据的数据一致性，在表上有活动事务的时候，不可以对元数据进行写入操作。为了避免 DML 与 DDL 冲突，保证读写的正确性。

在MySQL5.5中引入了 MDL，当对一张表进行增删改查的时候，加 MDL 读锁(共享)；当对表结构进行变更操作的时候，加 MDL 写锁(排他)。



当执行SELECT、INSERT、UPDATE、DELETE等语句时，添加的是元数据共享锁（SHARED_READ 【只有 SELECT】/ SHARED_WRITE），之间是兼容的。

当执行SELECT语句时，添加的是元数据共享锁（SHARED_READ），会阻塞元数据排他锁（EXCLUSIVE），之间是互斥的。



### 意向锁

> 允许在修改表数据的时候（加上了行锁）再次对表进行加锁（表级锁--意向锁），代表这张表已经加上了行锁，主要为了解决加上了行锁还加表锁的冲突问题，防止死锁发生

为了避免 **DML（数据操作语言）** 在执行时，加的行锁与表锁的冲突，在 InnoDB 中引入了意向锁，使得表锁不用检查每行数据是否加锁，使用意向锁来减少表锁的检查。

在执行 DML 操作时，会对涉及的行加行锁，同时也会对该表加上意向锁。其他客户端在对这张表加表锁的时候，会根据该表上所加的意向锁来判定是否可以成功加表锁，而不用逐行判断行锁情况了。

> 分类：
>
> - 意向共享锁( IS ): 由语句`select ... lock in share mode`添加 。 与 表锁共享锁(read)兼容，与表锁排他锁(write)互斥。
>
> ```SQL
> select * from user lock in share mode
> ```
>
> - 意向排他锁( IX ): 由insert、update、delete、select...for update添加 。与表锁共享锁(read)及排他锁(write)都互斥，意向锁之间不会互斥。
>
> ```SQL
> select * from user for update;
> ```
>
> 一旦事务提交了，意向共享锁、意向排他锁，都会自动释放。

- 意向共享锁与表读锁是兼容的

- 意向排他锁与表读锁、写锁都是互斥的

  

查看意向锁以及行锁的加锁情况：

```SQL
select object_schema,object_name,index_name,lock_type,lock_mode,lock_data from performance_schema.data_locks;
```



### 行级锁

> 通过索引上的索引项加锁

行级锁，每次操作锁住对应的行数据。锁定粒度最小，发生锁冲突的概率最低，并发度最高。应用在 InnoDB 存储引擎中。

InnoDB 的数据是基于索引组织的，行锁是通过对**索引上的索引项**加锁来实现的，而不是对记录加的锁。对于行级锁，主要分为以下三类：

- 行锁（Record Lock）：锁定单个行记录的锁，防止其他事务对此行进行 update 和 delete。在 RC、RR 隔离级别下都支持。

- 间隙锁（Gap Lock）：锁定索引记录间隙（不含该记录），确保索引记录间隙不变，防止其他事务在这个间隙进行 insert，产生幻读。在 RR 隔离级别下支持。

- 临键锁（Next-Key Lock）：行锁和间隙锁组合，同时锁住数据，并锁住数据前面的间隙Gap。在 RR 隔离级别下支持。



#### 行锁

> - InnoDB 的行锁是**针对于索引加的锁**，不通过索引条件检索数据，那么 InnoDB 将对表中的所有记录加锁，此时 就会升级为表锁。
> - 针对**唯一索引**进行检索时，对已存在的记录(where 之后的条件)进行等值匹配时，将会自动优化为行锁。
> - 没有索引，不会增加行锁，而是增加表锁。

InnoDB 实现了以下两种类型的行锁：

- 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排它锁。

- 排他锁（X）：允许获取排他锁的事务更新数据，阻止其他事务获得相同数据集的共享锁和排他锁。（insert、update、delete）

共享锁：

```SQL
SELECT ... LOCK IN SHARE MODE;
```

排他锁：

```SQL
SELECT ... FOR UPDATE;
```

> 注意：
>
> - 单纯的 select 不加锁

|             | S（共享锁） | X（排他锁） |
| ----------- | ----------- | ----------- |
| S(共享锁)   | 兼容        | 冲突        |
| X（排他锁） | 冲突        | 冲突        |



### 间隙锁 & 临键锁

**间隙锁：GAP**

- 索引上的等值查询(唯一索引)，**给不存在的记录加锁时**, 优化为间隙锁 。

- 索引上的等值查询(非唯一普通索引)，向右遍历时最后一个值不满足查询需求时，next-key 锁化为间隙锁。

- 索引上的范围查询(唯一索引)--会访问到不满足条件的第一个值为止（InnoDB 会从索引的起始点开始查找，一直访问到不满足查询条件的第一个值为止）。

> 默认情况下，InnoDB在 REPEATABLE READ 事务隔离级别运行，InnoDB使用 next-key 锁进行搜索和索引扫描，以防止幻读。
>
> **next-key 锁**：next-key 锁是 InnoDB 中的一种锁机制，它是行锁和间隙锁的组合。它用于防止幻读现象的发生，即防止在事务执行期间出现新的行插入到两个已存在的行之间，这可能导致事务看到之前不应该看到的新行。

> 注意：
>
> - 间隙锁唯一目的是防止其他事务插入间隙。间隙锁可以共存，一个事务采用的间隙锁不会阻止另一个事务在同一间隙上采用间隙锁。

