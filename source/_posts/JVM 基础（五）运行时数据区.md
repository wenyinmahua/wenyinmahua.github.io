---
title: JVM 基础（五）运行时数据区
date: 2024-09-01
updated: 2024-09-03
category: JVM
tags:
  - 笔记
cover: https://tse2-mm.cn.bing.net/th/id/OIP-C.iK1EFamgj6pjOvuhROEFNAHaEK?w=305&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---



# JVM 基础（五）运行时数据区

## 总结

> 🎉总结：
>
> 运行时数据区代表着 **Java 运行时管理的内存区域**，这里面存放了 Java 程序运行时需要使用的数据，分为线程共享和线程不共享两种：
>
> - 线程共享：线程共享的数据一般是共享资源
>   - 方法区：存储字节码通过 JVM 转换的 InstanceKlass 对象，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。
>   - 堆：存放的是 java.lang.Class 对象（类的元信息数据），以及几乎所有的对象实例
> - 线程不共享：
>   - **程序计数器**：存放当前线程下一条要执行的字节码指令的内存地址；（本地方法 native 不会记录）
>   - **Java 虚拟机栈**：存放 java 中非本地方法（没有被 native 修饰的方法）的信息；每一个方法都是一个栈帧，栈帧具有以下内容：局部变量表、操作数栈、动态链接、方法出口等
>     - 局部变量表：存放的是方法中定义的变量，实例方法中第一个位置还会存放 this 对象，同时也可以存放堆上的对象的引用；
>     - 操作数栈：是栈帧中虚拟机在执行指令过程中存放临时数据的一块区域；
>     - 帧数据：主要包含动态链接、方法出口、异常表的引用。
>       - 动态链接：保存了符号引用到运行时常量池中的变量的映射关系；
>       - 方法出口：执行的方法保存了调用者的下一条指令的地址；
>       - 异常表：异常处理流程
>   - **本地方法栈**：存放 java 中本地方法的信息。



> 🥊关于 Java 中对象的存储问题：
>
> 对于基本类型的对象：
>
> - `成员变量、静态变量以及数组`都会存储在堆上🔨
> - 局部变量会存放 Java 虚拟机栈中
>
> 对于引用类型的对象：
>
> - 对象的实际数据总是存放在堆上，无论是局部对象还是成员对象
>
>   以 Student student == new Student(); 为例:
>
>   - `new Student();`，会在堆上分配内存来存储 `Student`的实际数据，
>   - 其创建的局部变量`Student student`实际上只是一个引用，用来存储对`Student`对象的引用（即对象的地址）。
>   - ❗当方法结束后，局部变量 `student` 会从栈中移除，但是堆上的 `Student` 对象并不会直接移除，需要等待垃圾回收器在确定没有其他活动的引用指向该对象时，回收这部分内存。



![一图了解 java 8 内存结构](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241114112839024.png)

> 图片来源于[终于搞懂了Java8的内存结构，再也不纠结方法区和常量池了！-腾讯云开发者社区-腾讯云](https://cloud.tencent.com/developer/article/1810426)



类加载器将字节码文件加载到内存中会使用方法区和堆区两个区域，每一个字节码文件都会这样：

- 在方法区中解析字节码文件转换成一个 `InstanceKlass` 对象，这个对象通常被称为 `Class` 对象的内部表示。
- 在堆上生成 `java.lang.Class` 对象，这个对象是类的运行时表示形式，可以通过反射 API 访问类的信息。之后创建的对象实例，会在堆上为创建的实例分配内存。

**内存溢出：**指的是程序在使用某一块内存区域时，存放的数据需要占用的内存空间大小超过了虚拟机能提供的内存上限。

- Java 虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配地最大大小会出现内存溢出“StackOverflowError” 的错误
- 堆内存的大小是有上限的，当一直向堆中放入对象时，会抛出 `OutOfMemory` 错误



## 运行时数据区

**运行时数据区：**Java 虚拟机在运行 Java 程序过程中**管理的内存区域**。

![运行时数据区](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/output.png)

### 1. 程序计数器

> 💫在多线程环境下，线程会出现切换的情况，即一个线程的时间片用完了，需要将 CPU 资源让给其他线程使用。如果不进行切换，其他线程将不得不等待当前线程执行完毕后才能获得 CPU 资源，这可能会导致资源利用率低下，甚至可能导致某些线程长时间无法执行。
>
> 为了确保线程切换不会导致任务半途而废，操作系统会保存每个线程的执行状态，这一过程被称为线程的上下文切换。具体来说，上下文切换包括以下几个步骤：
>
> 1. **保存当前线程的状态**：
>    - 保存当前线程的程序计数器的值，记录该线程执行到哪一条指令。
>    - 保存当前线程的寄存器状态，包括通用寄存器、状态寄存器等。
>    - 保存当前线程的栈指针和其他必要的状态信息。
> 2. **恢复下一个线程的状态**：
>    - 从内存中恢复下一个线程的程序计数器的值，以便知道该线程上次执行到哪一条指令。
>    - 恢复下一个线程的寄存器状态。
>    - 恢复下一个线程的栈指针和其他必要的状态信息。
>
> 通过这种方式，当线程切换后，操作系统可以准确地恢复每个线程的执行状态，确保每个线程能够在上次中断的地方继续执行，而不是从头开始。这样不仅避免了重复执行的浪费，还保证了所有线程都能公平地获得 CPU 资源，提高了系统的整体效率。



> ❓方法的执行一定会有程序计数器吗
>
> - 如果当前线程正在执行的是本地方法（Native Method），则程序计数器的值为未定义（Undefined）。



程序计数器（Program Counter Register）PC 寄存器

- 在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的**偏移量转换成内存地址**，每一条字节码指令都会拥有一个内存地址。
- 每个线程会通过程序计数器来记录**当前要执行的字节码指令的实际内存地址**。

程序计数器可以控制程序指令的进行，实现**分支、跳转、异常**等逻辑。不管是分支、跳转、异常，只需要在程序计数器中放入要执行的指令地址即可。

在多线程执行情况下，Java 虚拟机需要通过程序计数器记录 CPU 切换前解释执行到那一句指令并继续解释运行，因此程序计数器是线程不共享的。

> 程序计数器在运行时不会出现内存溢出问题，因为每个线程只需要存储固定长度的内存地址。



### 2. Java 虚拟机栈

> 💫Java 虚拟机栈是每个线程私有的，用于存储方法调用中的基本数据，如**局部变量**、**操作数栈**、**动态链接**和**方法出口**等信息。
>
> Java 虚拟机栈保存的是 java 实现的方法，且不是被 native 修饰的方法
>
> 线程的创建会创建出 Java 虚拟机栈，而一个线程的执行了某个方法，那么该线程的 Java 虚拟机栈中会放入该方法的信息，称为 **栈帧**。

Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理**方法调用中的基本数据**，先进后出（First In Last Out）,**每一个方法**的调用使用一个**栈帧**（Stack Frame）来保存。

Java 虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行。由于方法可能会在不同线程中执行，每个线程都会包含一个自己的虚拟机栈。

Java 虚拟机栈的 **栈帧** 中主要包含三方面的内容：

- **局部变量表**：局部变量表的作用是在运行过程中存放所有的**局部变量**
- **操作数栈**：操作数栈是**栈帧**中虚拟机在执行指令过程中用来存放**临时数据**的一块区域
- **帧数据**：帧数据主要包含**动态链接**、**方法出口**、**异常表**的引用

> 因为每一个方法都有自己的局部变量、操作数等数据，所以每个方法的栈帧主要含有这些信息。



#### 2.1 局部变量表

> 局部变量表的作用是存放方法执行过程中所有的**局部变量**。

局部变量表分为两种：

- 字节码文件中的
  - 编译成字节码文件时就可以确定局部变量表的内容。
  - 在局部变量表中，变量下标从 0 开始，
- 栈帧中的，也就是保存在内存中
  - 栈帧中的局部变量表是根据字节码文件中的内容生成的。
  - 栈帧中的局部变量表是一个`数组`，数组长度在编译期间就确定了，数组中每一个位置称之为槽(slot) ，long 和 double 类型占用两个槽，其他类型占用一个槽。
    ![不同类型的变量所占的槽](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241025094350106.png)

> 具体来说：
>
> - 静态方法中的序号为 0 的位置存放的就是该方法中的变量；
> - 实例方法中的序号为 0 的位置存放的是 `this`，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址。
> - 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致。局部变量表保存的内容有：实例方法的`this`对象，方法的参数，方法体中声明的局部变量。

静态方法的字节码文件中的局部变量表![静态方法的局部变量表](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241025092128120.png)

实例方法的字节码文件中局部变量表

> 实例方法的字节码文件的局部变量表多了一个 this 对象，且 this 对象只会占一个槽

![实例方法的字节码文件中局部变量表](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241025094807199.png)





#### 2.2 操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来存放**中间数据**的一块区域。它是一种栈式的数据结构，如果一条指令将一个值压入操作数栈，则后面的指令可以弹出并使用该值。

在编译期就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小。

操作数栈的主要功能包括：

- 存放中间计算结果。
- 传递参数和返回值。
- 支持方法调用和返回。



#### 2.3 帧数据

帧数据主要包含动态链接、方法出口、异常表的引用。

> - **动态链接**：保存了符号引用到运行时常量池的内存地址的映射关系，支持方法调用链的动态链接。
> - **方法出口**：指方法在正确或异常结束时，当前栈帧被弹出，程序计数器指向上一个栈帧中的下一条指令的地址。
> - **异常表**：存放异常处理信息，包括异常捕获的生效范围和异常发生后跳转到的字节码指令位置，支持异常处理机制。

##### 动态链接

当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。

- 动态链接保存了**编号到运行时常量池的内存地址的映射关系**。

![动态链接](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/a6af2c98-7332-4b41-b5c7-c2e80784b047.png)

##### 方法出口

方法出口指的是方法在**正确或者异常结束**时，当前栈帧会被弹出，同时**程序计数器应该指向上一个栈帧中的下一条指令的地址。**



##### 异常表

异常表存放的是代码中异常的处理信息，包含了异常捕获的**生效范围**以及**异常发生后跳转到的字节码指令位置**。

![异常表](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/a10f0492-19c5-4628-83b8-fcf455b9f27d.png)

#### 2.4 栈内存溢出

> - **栈内存溢出**：当栈帧过多，占用内存超过栈内存可以分配的最大大小时，JVM会抛出 `StackOverflowError` 错误。
> - **常见原因**：递归调用过深或栈帧过大。
> - **处理方法**：优化递归调用，增加栈大小，使用迭代替代递归。

Java虚拟机栈如果**栈帧过多**，占用内存超过栈内存可以分配的最大大小就会出现内存溢出。Java 虚拟机栈内存溢出时会出现 `StackOverflowError` 的错误。（如无止尽的递归）

![栈溢出](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/7d9e6ebb-83c8-44c0-8006-86ecca0e67fd.png)

如果不指定栈的大小，JVM 将创建一个具有默认大小的栈。大小取决于操作系统和计算机的体系结构。

##### 修改栈内存的大小

要修改 Java 虚拟机栈的大小，可以使用虚拟机参数 `-Xss` 。

- 语法：-Xss栈大小
- 单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

```Java
-Xss1048576 
-Xss1024K      
-Xss1m
-Xss1g
```

> IDEA版本的设置方式：
>
> 1、点击修改配置Modify options
>
> 2、点击Add VM options
>
> 3、添加参数

**注意事项：**

1. 与-Xss类似，也可以使用 -XX:ThreadStackSize 调整标志来配置堆栈大小。

格式为： `-XX:ThreadStackSize=1024`

2. HotSpot JVM 对栈大小的最大值和最小值有要求：Windows（64位）下的 JDK8  测试最小值为`180k`，最大值为`1024m`。

   比如测试如下两个参数，会失效:

```
-Xss1k
-Xss1025m
```



3. 栈帧过大，如局部变量过多、操作数栈深度过大也会影响栈内存的大小。

> 一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数可以手动指定为 -Xss256k 节省内存。



### 3. 本地方法栈

- Java 虚拟机栈存储了 `Java` 方法调用时的**栈帧**，
- 本地方法栈存储的是 `native` 本地方法的**栈帧**。

在 Hotspot 虚拟机中，**Java 虚拟机栈和本地方法栈实现上使用了同一个栈空间。** 这意味着，无论是Java方法还是本地方法，它们的栈帧都存储在同一个栈中。

本地方法栈会在栈内存上生成一个**栈帧**，临时保存方法的参数，同时方便出现异常时也把本地方法的栈信息打印出来。

![栈空间的使用](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/6fe9420a-b06d-40d8-b8ec-5504d247b301.png)



### 4. 堆内存

#### 堆

- **作用**：存储对象实例和数组。
- **生命周期**：对象在堆上创建，垃圾回收器负责回收不再使用的对象。

> - 一般 Java 程序中**堆内存是空间最大的一块内存区域**。
> - **创建出来的对象都存在于堆上。**
> - 栈上的局部变量表中，可以**存放堆上对象的引用**。
> - 静态变量也可以存放堆对象的引用，通过静态变量就可以实现对象在线程之间共享。
> - 堆内存大小是有上限的，当对象一直向堆中放入对象达到上限之后，就会抛出 `OutOfMemory` 错误。



通过`new`关键字创建了两个`Student`类的对象，这两个对象会被存放在堆上。在栈上通过`s1`和`s2`两个局部变量保存堆上两个对象的地址，从而实现了引用关系的建立。

![堆内存](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/c5cf0920-fda7-4045-b013-956ad32eb93b.png)



#### 堆内存的三个重要的值

堆空间有三个需要关注的值: used、total、max。

- used 指的是当前已使用的堆内存，
- total 是 java 虚拟机已经分配的可用堆内存，
- max 是 java 虚拟机可以分配的最大堆内存。

堆内存 used total max 三个值可以通过`arthas` 的 `dashboard` 命令看到。

> 手动指定刷新频率（不指定默认5秒一次）：`dashboard –i  刷新频率(毫秒)`

1. 随着堆中的对象增多，当 total 可以使用的内存即将不足时，java 虚拟机会继续分配内存给堆。
2. 此时 used 达到了 total 的大小，Java 虚拟机会向操作系统申请更大的内存。
3. 但是这个申请过程不是无限的，total 最多只能与 max 相等。
4. 并不是说 used = max = total 就是内存溢出了，used = total < max 时就会发生内存溢出，跟垃圾回收器有关系。

> 如果不设置任何的虚拟机参数，max 默认是系统内存的 `1/4`，total 默认是系统内存的 `1/64`。在实际应用中一般都需要设置 total 和 max 的值。



#### 设置堆的大小

要修改**堆的大小**，可以使用虚拟机参数 `–Xmx（max最大值）`和 `-Xms (初始的 total)`。

语法：`-Xmx值 -Xms值`

单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

**限制：**Xmx必须大于 2 MB，Xms必须大于1MB

```Java
-Xms6291456
-Xms6144k
-Xms6m
-Xmx83886080
-Xmx81920k
-Xmx80m
```

查看堆的大小需要使用`arthas`的`memory`命令

> **建议：**
>
> Java 服务端程序开发时，**建议将 -Xmx 和 -Xms 设置为相同的值**，这样在程序启动之后可使用的总内存就是最大内存，而无需向 java 虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况



### 5. 方法区

> 方法区是一个抽象的概念（逻辑区域），具体实现有 永久代 和 元空间 两种

方法区是存放已被虚拟机加载的类的**基础信息**的位置，主要包含三部分内容：

- **类的元信息**，保存了所有类的**基本信息**（结构信息（名称、父类和接口）、字段信息、方法信息、常量池、访问修饰符、其他元信息（注解）），一般称之为 InstanceKlass 对象。在类加载阶段完成。
- **运行时常量池**，保存了**字节码文件**中的**常量池内容**
  - **静态常量池：**字节码文件中通过编号查表的方式找到常量
  - **运行时常量池：**常量池加载到内存中之后，可以通过内存地址快速定位到常量池中的内容

- **字符串常量池**，保存了**字符串常量**



#### 5.1 方法区的实现

每款 Java 虚拟机在实现上都各不相同，Hotspot 设计如下：

JDK7 及之前的版本将**方法区**存放在**堆区域**中的**永久代**空间（JDK 8 时被 元空间 替代，这时方法区放在元空间里面了），堆的大小由虚拟机参数来控制。`-XX:MaxPermSize=值来控制`

- 永久代（Permanent Generation，PermGen）是Java虚拟机（JVM）中一个特定的内存区域，它主要用于存储类的信息、常量池、字段和方法数据（方法区）等。

JDK8 及之后的版本将**方法区**存放在**元空间（Metaspace）**中，元空间位于**操作系统维护的直接内存（本地内存，与下文提出的直接内存不同，下文的直接内存也是存放在操作系统的直接内存中）**中，默认情况下只要不超过操作系统承受的上限，可以一直分配。可以使用d `-XX:MaxMetaspaceSize=值将元空间最大大小` 进行限制。

![方法区的实现](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20241031101234909.png)



如果大量字节码数据加载到方法区中，方法区会有**内存溢出**的情况。

> ❓为什么要用 Metaspace 替代永久代？
>
> 永久代受到 JVM 内存的限制，无法调整大小，而元空间使用的是本地内存，受本机可用内存的限制，虽然元空间也会出现内存溢出，但是概率变小了。



#### 5.2 类的元信息

方法区是用来存储每个类的**基本信息**（元信息），一般称之为 `InstanceKlass` 对象。其中就包含了类的**字段**、**方法**等字节码文件中的内容，同时还保存了运行过程中需要使用的**虚方法表**（实现多态的基础）等信息。

![类的元信息](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/efreferg1233242ef.png)

#### 5.3 运行时常量池

常量池中存放的是**字节码中的常量池内容**。

- 字节码文件中通过**编号**查表的方式找到**常量**，这种常量池称为**静态常量池**。
- 当常量池加载到内存中之后，可以通过**内存地址**快速的定位到常量池中的内容，这种常量池称为**运行时常量池**。用于存储编译期间生成的各种字面量和符号引用

![运行时常量池](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/580bee27-09be-4966-81d1-6834611c3fbe.png)

#### 5.4 字符串常量池

> 字符串常量池在 JDK 8 之后不再是方法区的一部分了，而是堆内存的一部分。（永久代被元空间替代，而元空间存放在）
>
> - 字符串常量池（StringTable）存储的是**代码中定义的常量字符串内容**。
> - Java 中的字符串常量池是运行时常量池的一个子集



早期设计时，字符串常量池是属于运行时常量池的一部分，他们存储的位置也是一致的。后续做出了调整，将字符串常量池和运行时常量池做了拆分。

![字符串常量池](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/c298a4d4-e2f7-40bf-a5a3-ed33ddfcb464.png)

#### 5.5 字符串常量池和运行时常量池的区别

1. 存储位置：
   - 运行时常量池位于方法区（Java 8及以后版本中位于元空间）。
   - 字符串常量池位于堆内存中。
2. 内容：
   - 运行时常量池存储各种字面量（整数、浮点数、字符串）和符号引用。
   - 字符串常量池专门存储字符串字面量和通过 `String.intern()` 方法 intern 的字符串对象。
     - 字符串字面量在编译时会被存储在字符串常量池中。
3. 作用：
   - 运行时常量池用于存储类的静态常量信息，支持动态链接。
   - 字符串常量池用于提高字符串的存储效率，避免重复存储相同的字符串。
4. 使用场景：
   - 运行时常量池在类加载过程中使用，存储类的静态信息。
   - 字符串常量池在字符串操作中使用，特别是涉及字符串比较和存储优化的场景。



#### 5.6 String的 intern

`String.intern()` 方法是可以手动将字符串放入字符串常量池中。（对象拿到的是字符串常量池中的引用，而非堆上的 String 对象的引用）`String.intern()` 方法可以将一个字符串对象添加到字符串常量池中，并返回字符串常量池中的引用（这个引用指向了堆中的字符串对象）。

- intern 方法会把第一次遇到的**字符串的引用**放入字符串常量池中。

```java
public class InternTest {
    public static void main(String[] args) {
       String s1 = "1";
       String s2 = "2";
       String s3 = "12";
       String s4 = s1 + s2;
       String s5 = "1"+"2";
       System.out.println(s3 == s4); // false 因为s3 直接指向了字符串常量池中的引用，而 s4 指向的是堆上的对象（这个过程中涉及了 StringBuilder 的 append 方法和 toString 方法，而 StringBuilder 对象的 toString 方法是返回一个 String 对象，即堆上的对象）
       System.out.println(s4.intern() == s3); // true s4 通过 intern 指向了常量池中的引用，s3 也是
       System.out.println(s4.intern() == s4); // false 一个是字符串常量池的引用，一个是堆上对象的引用
       System.out.println(s5 == s3); // true 两个都是字符串常量池的引用
    }
}
```



###  静态变量的存储

- JDK6 及之前的版本中，静态变量是存放在**方法区中**的，也就是永久代。
- JDK7 及之后的版本中，静态变量是存放在**堆中的 Class 对象**中，脱离了永久代。

> JDK 7 已经把原来存放在永久代的字符串常量池、静态变量在永久代中移除了，JDK 8 之后也取消了永久代的存在，被元空间代替了。



### 6. 直接内存

> ❓直接内存和元空间的关系到底是什么样的？
>
> - 元空间和直接内存是并列关系，都是存放在本地内存中（JVM 内存外的操作系统的内存）



> 直接内存不属于 Java 运行时的内存区域
>
> - 在 JDK 8 之后，用来保存方法区的数据
> - 用于 NIO 操作，提高 I/O操作的性能。当使用`java.nio.ByteBuffer.allocateDirect()` 方法创建直接缓冲区时，这些缓冲区的数据会被存储在直接内存中，而不是Java堆内存中。直接内存可以减少垃圾回收的压力，因为它不会被垃圾回收器管理。

在 Java 中，将文件读取到直接内存中，同时 Java 堆上维护直接内存的引用，减少**之前需要复制直接内存中的文件数据**的开销。

![直接内存的使用](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/c4664b79-32b7-471b-85db-82287a10496c.png)

要创建直接内存上的数据，可以使用 `ByteBuffer`

```java
ByteBuffer directBuffer = ByteBuffer.allocateDirect(size); // 会创建一个 size 大小的直接内存
```

如果服务器上部署了其他应用，为了避免将内存耗尽，需要设置直接内存的最大值。如果需要手动调整直接内存的大小，可以使用`XX:MaxDirectMemorySize=大小`

单位 k 或 K 表示千字节，m 或 M 表示兆字节，g 或 G 表示千兆字节。默认不设置该参数情况下，JVM 自动选择最大分配的大小。

以下示例以不同的单位说明如何将 直接内存大小设置为 1024 KB：

```Java
-XX:MaxDirectMemorySize=1m
-XX:MaxDirectMemorySize=1024k
-XX:MaxDirectMemorySize=1048576
```





不同 JDK 版本之间运行时数据区域的区别：

- JDK 6：
  - 方法区（永久代）位于堆里面
  - 字符串常量池位于方法区里面
- JDK 7：
  - 字符串从方法区移到堆里面了
- JDK 8：
  - 永久代被元空间代替，元空间存放在直接内存中
  - 字符串常量池在堆里面



