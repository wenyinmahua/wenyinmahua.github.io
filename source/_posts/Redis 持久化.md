---
title: Redis 持久化
date: 2024-01-27 
updated: 2024-05-03
tags: 
  - 面试
category: Redis
comments: true
cover: https://tse4-mm.cn.bing.net/th/id/OIP-C.Jed-UVwaIqf16oq5f8ATDQHaE8?w=251&h=180&c=7&r=0&o=5&dpr=1.3&pid=1.7
---
# Redis 持久化

> 注意：
>
> - 在内存不足的情况下，Redis 会根据配置的策略淘汰部分数据。



>Redis 的两种数据持久化方案：
>
>- Redis 提供了两种主要的持久化机制：RDB（Redis Database Backup）和 AOF（Append Only File）。
>- RDB 是通过周期性地创建`数据快照`来实现持久化的，这些快照是内存中数据的副本，存储在磁盘上。
>  - 执行 save 或 bgsave 指令进行 RDB
>
>- AOF 是通过记录`每个写操作`命令到一个文件中来实现持久化的，这些文件也存储在磁盘上。
>
>RDB 和 AOF 各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会**结合**两来使用。

## 1. RDB持久化

RDB 全称 Redis Database Backup file（Redis数据备份文件），也被叫做 Redis 数据快照。就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为 RDB 文件，默认是保存在当前运行目录。

### 1.1 执行时机

RDB持久化在四种情况下会运行：

- 执行 save 指令： **主进程** 立即执行依次 RDB， 其他所有命令都会阻塞（用于数据迁移）；

- 执行 bgsave 指令：开启**独立线程**异步执行RDB，主线程可以持续处理用户请求，不受影响；

- Redis 停机：Redis停机时会执行一次save命令，实现RDB持久化。

- 触发 RDB 条件时：

  > Redis 内部有触发 RDB 的机制，可以在redis.conf文件中找到，格式如下：
  >
  > ```properties
  > # 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB
  > save 900 1  
  > save 300 10  
  > save 60 10000 
  > ```
  >



### 1.2 RDB原理

![image-20240726222823461](https://web-tlias-mmh.oss-cn-beijing.aliyuncs.com/img/image-20240726222823461.png)

bgsave 开始时会 `fork` 主进程得到子进程，子进程共享主进程的内存数据。完成 fork 后读取内存数据并写入 RDB 文件。

fork 采用的是 copy-on-write（写时复制） 技术：

- 当主进程执行读操作时，访问共享内存；
- 当主进程执行写操作时，则会拷贝一份数据，执行写操作。这意味着当 Redis 需要修改数据时，它不会直接修改原始数据，而是创建一个新的副本并在副本上进行修改。这里所说的“副本”是指内存中的数据结构副本，并不是指整个数据库的副本。



**写时复制 (COW) 机制的工作原理**

1. **初始化阶段**:
   - 当 Redis 接收到 `BGSAVE` 命令时，它启动一个后台进程来生成 RDB 文件。
   - 初始时，Redis 数据库的所有数据仍然指向原有的内存地址。
2. **写操作发生时**:
   - 如果主进程在此期间接收到写操作，它不会直接修改原有数据，而是创建待修改数据的副本。
   - 只有在真正需要修改数据时才会创建副本，这减少了不必要的内存分配。
3. **RDB 文件生成**:
   - 后台进程读取原始数据（即没有被修改的数据），并将这些数据序列化到 RDB 文件中。
   - 如果数据在 RDB 文件生成过程中被修改了，那么后台进程读取的是修改前的原始数据。
4. **RDB 文件完成后**:
   - 一旦 RDB 文件生成完成，后台进程会通知主进程。
   - 主进程会将旧的 RDB 文件替换为新的 RDB 文件。
5. **副本的处理**:
   - 修改后的副本成为新的数据结构的一部分，而原始数据结构则不再被引用。（替换）
   - 对于未被修改的数据，由于它们仍然指向原始数据，所以不需要额外的内存开销。
   - 对于被修改的数据，由于创建了副本，这些副本成为新的数据结构的一部分。
   - 一旦数据结构不再被引用（例如，数据被删除或替换），这些副本会被垃圾回收机制清理。



**RDB 方式 bgsave 的基本流程:**

- fork 主进程得到一个子进程，共享内存空间
- 子进程读取内存数据并写入新的 RDB 文件
- 用新RDB文件替换旧的 RDB 文件

**RDB的缺点：**

- RDB执行间隔时间长，两次 RDB 之间写入数据有丢失的风险
- fork子进程、压缩、写出RDB文件都比较耗时



## 2.  AOF  持久化

AOF 全称为 Append Only File（追加文件）。Redis 处理的每一个写命令都会记录在 AOF 文件，可以看做是命令日志文件。

### 2.1  AOF配置

AOF 默认是关闭的，需要修改 redis.conf 配置文件来开启 AOF ：

```properties
# 是否开启AOF功能，默认是no
appendonly yes
# AOF文件的名称
appendfilename "appendonly.aof"
```



AOF 的命令记录的频率也可以通过 redis.conf 文件来配：

```properties
# 表示每执行一次写命令，立即记录到AOF文件
appendfsync always 
# 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案
appendfsync everysec 
# 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘
appendfsync no
```

> 在生产环境中，通常推荐使用 `everysec` 作为折衷方案。



**三种策略对比：**

|  配置项  |   刷盘时机   |          优点          |             缺点             |
| :------: | :----------: | :--------------------: | :--------------------------: |
|  Always  |   同步刷盘   | 可靠性高，几乎不丢数据 |          性能影响大          |
| everysec |   每秒刷盘   |        性能适中        |      最多丢失 1 秒数据       |
|    no    | 操作系统控制 |        性能最好        | 可靠性较差，可能丢失大量数据 |



### 2.2AOF文件重写

因为是记录命令，AOF 文件会比 RDB 文件大的多。而且 AOF 会记录对同一个 key 的多次写操作，但只有最后一次写操作才有意义。通过执行 `bgrewriteaof` 命令，可以让 AOF 文件执行重写功能，用最少的命令达到相同效果。

Redis也会在触发阈值时自动去重写 AOF 文件。阈值也可以在 redis.conf 中配置：

```properties
# AOF文件比上次文件 增长超过多少百分比则触发重写
auto-aof-rewrite-percentage 100
# AOF文件体积最小多大以上才触发重写 
auto-aof-rewrite-min-size 64mb 
```



## 3.RDB 和 AOF 对比

|                |                     RDB                      |                             AOF                             |
| -------------- | :------------------------------------------: | :---------------------------------------------------------: |
| 持久化方式     |             对其对整个内存做快照             |                    记录每一次执行的命令                     |
| 数据完整性     |          不完整，两次备份之间会丢失          |                  相对完整，取决于刷盘策略                   |
| 文件大小       |             会有压缩，文件体积小             |                   记录命令，文件体积很大                    |
| 宕机恢复速度   |                     很快                     |                             慢                              |
| 数据恢复优先级 |          低，因为数据完整性不如 AOF          |                      高，数据完整性高                       |
| 系统资源占用   |           高，大量 CPU 和内存消耗            | 低，主要是磁盘 IO 资源，但 AOF 重写会占用大量 CPU和内存资源 |
| 使用常见       | 可以容忍数分钟的数据丢失，追求更快的启动速度 |                    对数据安全性要求较高                     |





当 Redis 重启时，它可以从持久化文件中恢复数据。

- **RDB**:
  - RDB 是通过定期保存内存中的数据快照到磁盘上实现持久化的。
  - 当 Redis 重启时，它会从最新的 RDB 文件中恢复数据。
- **AOF**:
  - AOF 通过记录所有写命令到一个文件中来实现持久化。
  - 当 Redis 重启时，它会重放 AOF 文件中的命令来重建数据集。